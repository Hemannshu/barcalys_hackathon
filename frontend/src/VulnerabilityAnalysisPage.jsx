import React, { useState, useEffect, useCallback } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import './VulnerabilityAnalysisPage.css';

const calculateLocalAnalysis = (password) => {
  // Calculate entropy bits
  const charsetSize = (
    (/[a-z]/.test(password) ? 26 : 0) +
    (/[A-Z]/.test(password) ? 26 : 0) +
    (/[0-9]/.test(password) ? 10 : 0) +
    (/[^A-Za-z0-9]/.test(password) ? 32 : 0)
  );
  const entropyBits = Math.log2(Math.pow(charsetSize, password.length));
  
  // Calculate strength score
  let strengthScore = Math.min(100, Math.floor(entropyBits * 1.5));
  
  // Apply penalties
  if (/(.)\1{2,}/.test(password)) strengthScore -= 20;
  if (/[a-z]{4,}/.test(password)) strengthScore -= 15;
  if (/123|abc|qwerty/.test(password)) strengthScore -= 30;
  
  // Determine strength category
  let strengthCategory;
  if (strengthScore >= 80) strengthCategory = 'Very Strong';
  else if (strengthScore >= 60) strengthCategory = 'Strong';
  else if (strengthScore >= 40) strengthCategory = 'Moderate';
  else if (strengthScore >= 20) strengthCategory = 'Weak';
  else strengthCategory = 'Very Weak';
  
  // Calculate crack times
  const guessesPerSecond = {
    online: 100,
    offline_fast: 1e10,
    offline_slow: 1e4
  };
  
  const possibleCombinations = Math.pow(charsetSize, password.length);
  const crackTimes = {};
  
  Object.entries(guessesPerSecond).forEach(([type, speed]) => {
    const seconds = possibleCombinations / (2 * speed);
    crackTimes[type] = {
      seconds,
      time_readable: formatTime(seconds)
    };
  });
  
  // Identify patterns and vulnerabilities
  const patterns = [];
  const attackTypes = [];
  
  if (/(.)\1{2,}/.test(password)) {
    patterns.push({
      type: 'Repetition',
      pattern: 'Repeated characters',
      severity: 'high'
    });
  }
  
  if (/[a-z]{4,}/.test(password)) {
    patterns.push({
      type: 'Dictionary',
      pattern: 'Common word pattern',
      severity: 'medium'
    });
  }
  
  if (/123|abc|qwerty/.test(password)) {
    patterns.push({
      type: 'Sequence',
      pattern: 'Common sequence',
      severity: 'high'
    });
  }
  
  if (password.length < 8) {
    attackTypes.push({
      name: 'Brute Force',
      description: 'Password is too short and can be quickly brute forced',
      risk_level: 'High'
    });
  }
  
  if (/^[a-zA-Z]+$/.test(password)) {
    attackTypes.push({
      name: 'Dictionary Attack',
      description: 'Password contains only letters and may be vulnerable to dictionary attacks',
      risk_level: 'Medium'
    });
  }
  
  return {
    strength_score: Math.max(0, strengthScore),
    strength_category: strengthCategory,
    suggestions: [
      'Use a mix of character types',
      'Avoid common patterns and sequences',
      'Make the password longer',
      'Avoid repeated characters'
    ],
    details: {
      entropy_bits: entropyBits,
      crack_times: crackTimes,
      length: password.length,
      has_uppercase: /[A-Z]/.test(password),
      has_lowercase: /[a-z]/.test(password),
      has_numbers: /[0-9]/.test(password),
      has_symbols: /[^A-Za-z0-9]/.test(password)
    },
    patterns,
    attack_types: attackTypes,
    is_local_analysis: true
  };
};

const formatTime = (seconds) => {
  if (seconds < 1) return 'instantly';
  if (seconds < 60) return `${seconds.toFixed(1)} seconds`;
  if (seconds < 3600) return `${(seconds / 60).toFixed(1)} minutes`;
  if (seconds < 86400) return `${(seconds / 3600).toFixed(1)} hours`;
  if (seconds < 31536000) return `${(seconds / 86400).toFixed(1)} days`;
  return `${(seconds / 31536000).toFixed(1)} years`;
};

const VulnerabilityAnalysisPage = () => {
  const [password, setPassword] = useState('');
  const [analysis, setAnalysis] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const location = useLocation();
  const navigate = useNavigate();

  useEffect(() => {
    // Get password from navigation state if available
    if (location.state && location.state.password) {
      console.log('Password received from navigation state:', location.state.password);
      setPassword(location.state.password);
      analyzePassword(location.state.password);
    }
  }, [location]);

  const analyzePassword = async (pwdToAnalyze) => {
    setIsLoading(true);
    setError(null);
    
    try {
      console.log('Analyzing password:', pwdToAnalyze);
      
      // Get token from localStorage
      const token = localStorage.getItem('token');
      if (!token) {
        setError('Authentication required. Please log in.');
        setIsLoading(false);
        return;
      }
      
      let analysisResult;
      
      try {
        const response = await fetch('http://localhost:5000/api/analyze-password', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({ password: pwdToAnalyze })
        });
        
        if (!response.ok) {
          if (response.status === 401) {
            setError('Authentication required. Please log in.');
            navigate('/login');
            return;
          }
          throw new Error(`Error: ${response.status}`);
        }
        
        const data = await response.json();
        console.log('Backend analysis result:', data);
        
        analysisResult = {
          strength_score: data.score,
          strength_category: data.strength,
          suggestions: data.suggestions,
          details: data.details,
          patterns: data.patterns || [],
          attack_types: data.attack_types || [],
          is_backend_analysis: true
        };
      } catch (backendError) {
        console.warn('Backend analysis failed, using local analysis:', backendError);
        analysisResult = calculateLocalAnalysis(pwdToAnalyze);
      }
      
      setAnalysis(analysisResult);
      setError(analysisResult.is_local_analysis ? 
        'Note: Using local analysis mode due to server unavailability' : null);
      
    } catch (err) {
      console.error('Error in password analysis:', err);
      const localAnalysis = calculateLocalAnalysis(pwdToAnalyze);
      setAnalysis(localAnalysis);
      setError('Using local analysis due to server error');
    } finally {
      setIsLoading(false);
    }
  };

  const handlePasswordChange = (e) => {
    setPassword(e.target.value);
  };

  const handleAnalyzeClick = () => {
    analyzePassword(password);
  };

  const getStrengthColor = (score) => {
    if (score >= 80) return '#4CAF50'; // Green
    if (score >= 60) return '#8BC34A'; // Light Green
    if (score >= 40) return '#FFC107'; // Amber
    if (score >= 20) return '#FF9800'; // Orange
    return '#F44336'; // Red
  };

  const getRiskLevelColor = (level) => {
    if (level === 'High') return '#F44336'; // Red
    if (level === 'Medium') return '#FF9800'; // Orange
    return '#4CAF50'; // Green
  };

  return (
    <div className="vulnerability-analysis-container">
      <h1>Password Vulnerability Analysis</h1>
      
      <div className="password-input-section">
        <input
          type="text"
          value={password}
          onChange={handlePasswordChange}
          placeholder="Enter password to analyze"
          className="password-input"
        />
        <button 
          onClick={handleAnalyzeClick} 
          className="analyze-button"
          disabled={isLoading || !password}
        >
          {isLoading ? 'Analyzing...' : 'Analyze Password'}
        </button>
      </div>
      
      {error && <div className="error-message">{error}</div>}
      
      {isLoading && (
        <div className="loading-spinner">
          <div className="spinner"></div>
          <p>Analyzing password strength...</p>
        </div>
      )}
      
      {analysis && !isLoading && (
        <div className="analysis-results">
          <div className="strength-meter">
            <h2>Password Strength</h2>
            <div className="strength-bar-container">
              <div 
                className="strength-bar" 
                style={{ 
                  width: `${analysis.strength_score}%`,
                  backgroundColor: getStrengthColor(analysis.strength_score)
                }}
              ></div>
            </div>
            <div className="strength-score">
              <span>Score: </span>
              <span style={{ color: getStrengthColor(analysis.strength_score) }}>
                {analysis.strength_score}/100
              </span>
              <span> ({analysis.strength_category})</span>
              {analysis.confidence && (
                <span className="confidence-score">
                  {' '}â€¢ ML Confidence: {(analysis.confidence * 100).toFixed(1)}%
                </span>
              )}
            </div>
            <div className="password-metrics">
              <div className="metric-item">
                <span>Entropy: </span>
                <span>{analysis.details.entropy_bits.toFixed(2)} bits</span>
              </div>
              <div className="metric-item">
                <span>Character Types: </span>
                <span>{analysis.details.char_types}/4</span>
              </div>
              {analysis.details.repeating_chars > 0 && (
                <div className="metric-item warning">
                  <span>Repeating Characters: </span>
                  <span>{analysis.details.repeating_chars}</span>
                </div>
              )}
            </div>
          </div>
          
          <div className="crack-time-section">
            <h2>Estimated Time to Crack</h2>
            <div className="crack-time-grid">
              {Object.entries(analysis.details.crack_times).map(([algo, data]) => (
                <div key={algo} className="crack-time-item">
                  <h3>{algo.toUpperCase()}</h3>
                  <p>{data.time_readable}</p>
                </div>
              ))}
            </div>
          </div>
          
          {analysis.patterns.length > 0 && (
            <div className="patterns-section">
              <h2>Identified Patterns</h2>
              <ul className="patterns-list">
                {analysis.patterns.map((pattern, index) => (
                  <li key={index} className={`pattern-item ${pattern.severity}`}>
                    <span className="pattern-type">{pattern.type}:</span>
                    <span className="pattern-value">{pattern.pattern}</span>
                    <span className="pattern-severity">{pattern.severity}</span>
                  </li>
                ))}
              </ul>
            </div>
          )}
          
          {analysis.attack_types.length > 0 && (
            <div className="attack-types-section">
              <h2>Vulnerable to Attacks</h2>
              <div className="attack-types-grid">
                {analysis.attack_types.map((attack, index) => (
                  <div 
                    key={index} 
                    className="attack-type-item"
                    style={{ borderColor: getRiskLevelColor(attack.risk_level) }}
                  >
                    <h3>{attack.name}</h3>
                    <p>{attack.description}</p>
                    <div className="risk-level" style={{ backgroundColor: getRiskLevelColor(attack.risk_level) }}>
                      {attack.risk_level} Risk
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
          
          {analysis.suggestions.length > 0 && (
            <div className="suggestions-section">
              <h2>Improvement Suggestions</h2>
              <ul className="suggestions-list">
                {analysis.suggestions.map((suggestion, index) => (
                  <li key={index} className="suggestion-item">
                    {suggestion}
                  </li>
                ))}
              </ul>
            </div>
          )}

          {/* New ML Analysis Section */}
          <div className="ml-analysis-section">
            <h2>Machine Learning Analysis</h2>
            
            <div className="ml-metrics-grid">
              {/* ML Confidence Score */}
              <div className="ml-metric-card">
                <h3>ML Confidence</h3>
                <div className="ml-metric-value" style={{
                  color: analysis.confidence > 0.7 ? '#4CAF50' : 
                         analysis.confidence > 0.4 ? '#FFC107' : '#F44336'
                }}>
                  {(analysis.confidence * 100).toFixed(1)}%
                </div>
                <div className="ml-metric-description">
                  Model's confidence in its analysis
                </div>
              </div>

              {/* Character Composition */}
              <div className="ml-metric-card">
                <h3>Character Types</h3>
                <div className="char-types-grid">
                  <div className={`char-type ${analysis.details.has_uppercase ? 'present' : ''}`}>
                    ABC
                  </div>
                  <div className={`char-type ${analysis.details.has_lowercase ? 'present' : ''}`}>
                    abc
                  </div>
                  <div className={`char-type ${analysis.details.has_numbers ? 'present' : ''}`}>
                    123
                  </div>
                  <div className={`char-type ${analysis.details.has_symbols ? 'present' : ''}`}>
                    #@!
                  </div>
                </div>
                <div className="ml-metric-description">
                  {analysis.details.char_types}/4 character types used
                </div>
              </div>

              {/* Entropy Analysis */}
              <div className="ml-metric-card">
                <h3>Entropy Analysis</h3>
                <div className="ml-metric-value">
                  {analysis.details.entropy_bits.toFixed(2)} bits
                </div>
                <div className="entropy-bar">
                  <div 
                    className="entropy-fill"
                    style={{ width: `${Math.min(100, analysis.details.entropy_bits)}%` }}
                  />
                </div>
                <div className="ml-metric-description">
                  Password randomness score
                </div>
              </div>

              {/* Pattern Detection */}
              {analysis.details.repeating_chars > 0 && (
                <div className="ml-metric-card warning">
                  <h3>Pattern Warning</h3>
                  <div className="ml-metric-value">
                    {analysis.details.repeating_chars} repeating characters
                  </div>
                  <div className="ml-metric-description">
                    Repeated characters make your password weaker
                  </div>
                </div>
              )}
            </div>

            {/* ML-Based Recommendations */}
            {analysis.confidence < 0.7 && (
              <div className="ml-recommendations">
                <h3>ML Model Recommendations</h3>
                <ul className="ml-recommendations-list">
                  {analysis.confidence < 0.4 && (
                    <li>Your password structure is highly unusual - consider using a more standard pattern</li>
                  )}
                  {analysis.details.char_types < 3 && (
                    <li>Increase complexity by using more character types</li>
                  )}
                  {analysis.details.entropy_bits < 50 && (
                    <li>Increase password randomness for better security</li>
                  )}
                </ul>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
};

export default VulnerabilityAnalysisPage; 