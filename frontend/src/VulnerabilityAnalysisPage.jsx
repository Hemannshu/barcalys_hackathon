import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import './VulnerabilityAnalysisPage.css';
import CryptoJS from 'crypto-js';
import { Chart as ChartJS, RadialLinearScale, PointElement, LineElement, Filler, Tooltip, Legend } from 'chart.js';
import { Radar } from 'react-chartjs-2';

ChartJS.register(RadialLinearScale, PointElement, LineElement, Filler, Tooltip, Legend);

const calculateLocalAnalysis = (password) => {
  if (!password) {
    return {
      strength_score: 0,
      strength_category: 'Not Analyzed',
      confidence: 0,
      details: {
        entropy: 0,
        length: 0,
        has_uppercase: false,
        has_lowercase: false,
        has_numbers: false,
        has_symbols: false,
        char_types: 0,
        repeating_chars: 0
      },
      patterns: [],
      attack_types: [],
      is_local_analysis: true
    };
  }

  // 1. Basic character analysis
  const charTypes = {
    uppercase: /[A-Z]/.test(password),
    lowercase: /[a-z]/.test(password),
    numbers: /[0-9]/.test(password),
    symbols: /[^A-Za-z0-9]/.test(password)
  };
  
  const charCounts = {
    uppercase: (password.match(/[A-Z]/g) || []).length,
    lowercase: (password.match(/[a-z]/g) || []).length,
    numbers: (password.match(/[0-9]/g) || []).length,
    symbols: (password.match(/[^A-Za-z0-9]/g) || []).length
  };

  // 2. Calculate base entropy
  const charsetSize = (charTypes.uppercase ? 26 : 0) +
                     (charTypes.lowercase ? 26 : 0) +
                     (charTypes.numbers ? 10 : 0) +
                     (charTypes.symbols ? 32 : 0);
  
  let entropy = Math.log2(Math.pow(charsetSize || 1, password.length));

  // 3. Pattern detection and penalties
  const patterns = {
    repeatingChars: /(.)\1{2,}/g,
    sequentialLetters: /(?:abc|bcd|cde|def|efg|fgh|ghi|hij|ijk|jkl|klm|lmn|nop|opq|pqr|rst|stu|tuv|uvw|vwx|xyz)/i,
    sequentialNumbers: /(?:012|123|234|345|456|567|678|789|987|876|765|654|543|432|321|210)/,
    keyboardPatterns: /(?:qwerty|asdfgh|zxcvbn|qazwsx|qweasd)/i,
    commonWords: /(?:password|admin|welcome|login|user|guest|123456|qwerty|letmein|dragon)/i,
    dates: /(?:19|20)\d{2}|(?:0[1-9]|1[0-2])(?:0[1-9]|[12]\d|3[01])/
  };

  const foundPatterns = [];
  let patternPenalty = 0;

  Object.entries(patterns).forEach(([type, regex]) => {
    const matches = (password.match(regex) || []).length;
    if (matches > 0) {
      foundPatterns.push({
        type,
        matches,
        severity: type === 'commonWords' ? 'critical' :
                 type === 'keyboardPatterns' ? 'high' :
                 type === 'sequentialLetters' || type === 'sequentialNumbers' ? 'medium' : 'low'
      });

      switch (type) {
        case 'repeatingChars':
          patternPenalty += matches * 8;
          break;
        case 'sequentialLetters':
        case 'sequentialNumbers':
          patternPenalty += matches * 10;
          break;
        case 'keyboardPatterns':
          patternPenalty += matches * 12;
          break;
        case 'commonWords':
          patternPenalty += matches * 15;
          break;
        case 'dates':
          patternPenalty += matches * 10;
          break;
      }
    }
  });

  // 4. Calculate final entropy and strength score
  entropy = Math.max(0, entropy - patternPenalty);
  const normalizedEntropy = Math.min(100, Math.max(0, entropy * 2));
  
  // Calculate strength score (0-10)
  const strengthScore = Math.round(normalizedEntropy / 10);

  // 5. Calculate crack times
  const HARDWARE_SPEEDS = {
    online_throttled: 1000,                    // 1k guesses/second (throttled online attack)
    online_unthrottled: 100_000,              // 100k guesses/second (unthrottled online attack)
    offline_slow_hash: 10_000_000,            // 10M guesses/second (bcrypt/PBKDF2)
    offline_fast_hash: 10_000_000_000,        // 10B guesses/second (SHA1/MD5)
    offline_gpu_farm: 1_000_000_000_000,      // 1T guesses/second (GPU cluster)
    quantum: 10_000_000_000_000              // 10T guesses/second (future quantum)
  };

  // Calculate base entropy and character space
  let entropyPenalty = 0;
  const patterns2 = {
    repeating: /(.)\1{2,}/,
    sequential_nums: /(?:012|123|234|345|456|567|678|789|987|876|765|654|543|432|321|210)/,
    sequential_chars: /(?:abc|bcd|cde|def|efg|fgh|ghi|hij|ijk|jkl|klm|lmn|nop|opq|pqr|rst|stu|tuv|uvw|vwx|wxy|xyz)/i,
    keyboard_patterns: /(?:qwerty|asdfgh|zxcvbn|qazwsx|qweasd)/i,
    common_words: /(?:password|admin|welcome|login|user|guest|123456|qwerty|letmein|dragon)/i,
    dates: /(?:19\d{2}|20\d{2}|0[1-9]|1[0-2])(?:0[1-9]|[12]\d|3[01])/
  };

  // Increased pattern penalties for more realistic estimates
  Object.entries(patterns2).forEach(([type, regex]) => {
    if (regex.test(password)) {
      switch (type) {
        case 'repeating':
          entropyPenalty += 30;
          break;
        case 'sequential_nums':
        case 'sequential_chars':
          entropyPenalty += 35;
          break;
        case 'keyboard_patterns':
          entropyPenalty += 40;
          break;
        case 'common_words':
          entropyPenalty += 45;
          break;
        case 'dates':
          entropyPenalty += 25;
          break;
      }
    }
  });

  // Calculate effective entropy with more realistic adjustments
  const effectiveEntropy = Math.max(1, (entropy - entropyPenalty));

  // Dictionary attack optimization factor
  const dictionaryFactor = /^[a-zA-Z]+$/.test(password) ? 100 : 1;

  // Calculate crack times for different attack scenarios
  const crackTimes = {};
  Object.entries(HARDWARE_SPEEDS).forEach(([method, speed]) => {
    const combinations = Math.pow(charsetSize || 1, password.length);
    const seconds = (combinations / speed) * dictionaryFactor;
    crackTimes[method] = {
      seconds,
      time_readable: formatTime(seconds)
    };
  });

  // Determine strength category based on crack time
  const fastestCrack = Object.values(crackTimes)
    .reduce((fastest, current) => 
      current.seconds < fastest.seconds ? current : fastest
    );

  let strengthCategory;
  if (fastestCrack.seconds >= 31536000000000000) strengthCategory = 'Very Strong';    // 1 quadrillion years
  else if (fastestCrack.seconds >= 31536000000000) strengthCategory = 'Strong';       // 1 trillion years
  else if (fastestCrack.seconds >= 31536000000) strengthCategory = 'Moderate';        // 1 billion years
  else if (fastestCrack.seconds >= 31536000) strengthCategory = 'Weak';              // 1 year
  else strengthCategory = 'Very Weak';

  // Attack types analysis
  const attackTypes = {
    DICTIONARY: {
      name: "Dictionary Attack",
      description: "Uses common words/phrases",
      indicator: (p) => /[a-z]{4,}/i.test(p) && !/[^a-z0-9]/i.test(p),
      severity: "high"
    },
    BRUTE_FORCE: {
      name: "Brute Force",
      description: "Tries all combinations",
      indicator: (p) => p.length < 8,
      severity: "medium"
    },
    PATTERN: {
      name: "Pattern",
      description: "Targets common sequences",
      indicator: (p) => /123|abc|qwerty|asdf|password/i.test(p),
      severity: "high"
    },
    REPEATING: {
      name: "Repeating",
      description: "Exploits repeated patterns",
      indicator: (p) => /(.)\1{2,}/.test(p),
      severity: "medium"
    },
    PERSONAL_INFO: {
      name: "Personal Info",
      description: "Uses names/birthdays",
      indicator: (p) => p.toLowerCase().includes('barclays'),
      severity: "high"
    },
    SPRAYING: {
      name: "Password Spraying",
      description: "Tries common passwords",
      indicator: (p) => ['password', '123456', 'welcome'].includes(p.toLowerCase()),
      severity: "critical"
    }
  };

  // Calculate vulnerabilities
  const vulnerabilities = Object.entries(attackTypes)
    .filter(([_, attack]) => attack.indicator(password))
    .map(([key, attack]) => ({
      id: key,
      name: attack.name,
      description: attack.description,
      severity: attack.severity
    }));

  // Generate suggestions
  const suggestions = [];
  if (password.length < 12) {
    suggestions.push('Increase password length to at least 12 characters');
  }
  if (!charTypes.uppercase) {
    suggestions.push('Add uppercase letters');
  }
  if (!charTypes.lowercase) {
    suggestions.push('Add lowercase letters');
  }
  if (!charTypes.numbers) {
    suggestions.push('Add numbers');
  }
  if (!charTypes.symbols) {
    suggestions.push('Add special characters');
  }
  if (foundPatterns.length > 0) {
    suggestions.push('Avoid common patterns and sequences');
  }

  return {
    strength_score: strengthScore,
    strength_category: strengthCategory,
    confidence: 0.95,
    suggestions,
    details: {
      entropy: Math.round(effectiveEntropy),
      crack_times: crackTimes,
      length: password.length,
      has_uppercase: charTypes.uppercase,
      has_lowercase: charTypes.lowercase,
      has_numbers: charTypes.numbers,
      has_symbols: charTypes.symbols,
      char_types: Object.values(charTypes).filter(Boolean).length,
      repeating_chars: (password.match(/(.)\1{2,}/g) || []).length,
      charCounts
    },
    patterns: foundPatterns,
    attack_types: vulnerabilities,
    is_local_analysis: true
  };
};

const formatTime = (seconds) => {
  if (seconds < 1e-9) return 'nano-seconds';
  if (seconds < 1e-6) return 'micro-seconds';
  if (seconds < 1e-3) return 'milli-seconds';
  if (seconds < 1) return `${(seconds * 1000).toFixed(2)} milliseconds`;
  if (seconds < 60) return `${seconds.toFixed(1)} seconds`;
  if (seconds < 3600) return `${(seconds / 60).toFixed(1)} minutes`;
  if (seconds < 86400) return `${(seconds / 3600).toFixed(1)} hours`;
  if (seconds < 31536000) return `${(seconds / 86400).toFixed(1)} days`;
  if (seconds < 31536000 * 100) return `${(seconds / 31536000).toFixed(1)} years`;
  return 'centuries';
};

// Add this function near the top with other utility functions
const performLocalHashAnalysis = (hash, algorithm) => {
  // Basic hash analysis without server
  const analysis = {
    vulnerability_score: 0,
    confidence: 0.85,
    algorithm_details: {
      name: algorithm,
      bit_length: getBitLength(algorithm),
      quantum_resistant: isQuantumResistant(algorithm)
    },
    risk_factors: [],
    recommendations: []
  };

  // Analyze hash characteristics
  if (algorithm === 'md5') {
    analysis.vulnerability_score = 0.8;
    analysis.risk_factors.push({
      type: 'Collision Vulnerability',
      severity: 'high',
      description: 'MD5 is cryptographically broken and susceptible to collision attacks.'
    });
    analysis.recommendations.push(
      'Migrate to a stronger hash algorithm like SHA-256 or BLAKE2b',
      'If possible, rehash existing data with a stronger algorithm'
    );
  } else if (algorithm === 'sha1') {
    analysis.vulnerability_score = 0.6;
    analysis.risk_factors.push({
      type: 'Theoretical Weakness',
      severity: 'medium',
      description: 'SHA-1 has known theoretical weaknesses and is not recommended for new applications.'
    });
    analysis.recommendations.push(
      'Consider upgrading to SHA-256 or newer hash functions',
      'Monitor for any new vulnerabilities in SHA-1'
    );
  } else if (algorithm === 'sha256') {
    analysis.vulnerability_score = 0.2;
    analysis.risk_factors.push({
      type: 'Quantum Computing',
      severity: 'low',
      description: 'While currently secure, may be vulnerable to future quantum computing attacks.'
    });
    analysis.recommendations.push(
      'Consider quantum-resistant algorithms for long-term security',
      'Implement regular security reviews'
    );
  } else if (algorithm === 'sha3_256') {
    analysis.vulnerability_score = 0.1;
    analysis.risk_factors.push({
      type: 'Implementation',
      severity: 'low',
      description: 'Strong algorithm, but ensure proper implementation and salt usage.'
    });
    analysis.recommendations.push(
      'Ensure proper implementation of the algorithm',
      'Use appropriate salt values'
    );
  } else if (algorithm === 'blake2b') {
    analysis.vulnerability_score = 0.1;
    analysis.risk_factors.push({
      type: 'Best Practice',
      severity: 'low',
      description: 'Modern and secure, but ensure proper implementation.'
    });
    analysis.recommendations.push(
      'Maintain up-to-date implementations',
      'Follow security best practices for key handling'
    );
  }

  // Validate hash format
  const expectedLength = getExpectedLength(algorithm);
  if (!isValidHashFormat(hash, algorithm)) {
    analysis.risk_factors.push({
      type: 'Format Error',
      severity: 'high',
      description: `Invalid hash format for ${algorithm.toUpperCase()}. Expected length: ${expectedLength} characters.`
    });
    analysis.recommendations.push('Verify the hash was generated correctly');
    analysis.vulnerability_score = 1.0;
  }

  return analysis;
};

// Helper functions for local hash analysis
const getBitLength = (algorithm) => {
  const bitLengths = {
    md5: 128,
    sha1: 160,
    sha256: 256,
    sha3_256: 256,
    blake2b: 512
  };
  return bitLengths[algorithm] || 256;
};

const isQuantumResistant = (algorithm) => {
  return ['sha3_256', 'blake2b'].includes(algorithm);
};

const getExpectedLength = (algorithm) => {
  const lengths = {
    md5: 32,
    sha1: 40,
    sha256: 64,
    sha3_256: 64,
    blake2b: 128
  };
  return lengths[algorithm] || 64;
};

const isValidHashFormat = (hash, algorithm) => {
  const expectedLength = getExpectedLength(algorithm);
  const hexRegex = /^[0-9a-fA-F]+$/;
  return hash.length === expectedLength && hexRegex.test(hash);
};

const VulnerabilityAnalysisPage = () => {
  const location = useLocation();
  const navigate = useNavigate();
  
  // Initialize states with data from navigation if available
  const [password, setPassword] = useState(location.state?.analysisData?.password || '');
  const [analysis, setAnalysis] = useState(location.state?.analysisData ? {
    strength_score: location.state.analysisData.score || 0,
    strength_category: location.state.analysisData.category || 'Unknown',
    confidence: location.state.analysisData.confidence || 0,
    details: {
      entropy: location.state.analysisData.entropy || 0,
      length: location.state.analysisData.features?.length || 0,
      has_upper: location.state.analysisData.features?.has_upper || false,
      has_lower: location.state.analysisData.features?.has_lower || false,
      has_digit: location.state.analysisData.features?.has_digit || false,
      has_special: location.state.analysisData.features?.has_special || false,
      char_types: location.state.analysisData.features?.char_types || 0,
      repeating_chars: 0
    },
    patterns: location.state.analysisData.patterns || [],
    crack_times: location.state.analysisData.crack_times || {}
  } : {
    strength_score: 0,
    strength_category: 'Not Analyzed',
    confidence: 0,
    details: {
      entropy: 0,
      length: 0,
      has_upper: false,
      has_lower: false,
      has_digit: false,
      has_special: false,
      char_types: 0,
      repeating_chars: 0
    },
    patterns: [],
    crack_times: {}
  });
  
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  
  // Hash analysis states
  const [hashValue, setHashValue] = useState('');
  const [hashAlgorithm, setHashAlgorithm] = useState('sha256');
  const [generatedHashes, setGeneratedHashes] = useState(null);
  const [selectedGeneratedHash, setSelectedGeneratedHash] = useState(null);
  const [hashAnalysis, setHashAnalysis] = useState({
    vulnerability_score: 0,
    confidence: 0,
    algorithm_details: {
      name: '',
      bit_length: 0,
      quantum_resistant: false
    },
    risk_factors: [],
    recommendations: []
  });
  const [isHashLoading, setIsHashLoading] = useState(false);
  const [hashError, setHashError] = useState(null);

  // Remove the redirect effect
  useEffect(() => {
    if (password && !location.state?.analysisData) {
      analyzePassword(password);
    }
  }, [password, location.state]);

  // Add function to calculate attack vulnerabilities
  const calculateAttackVulnerabilities = (password) => {
    if (!password) return [0, 0, 0, 0, 0, 0];

    // Dictionary Attack vulnerability (based on common words and patterns)
    const dictionaryVulnerability = /^[a-zA-Z]+$/.test(password) ? 0.8 : 
                                  /password|admin|123456/.test(password.toLowerCase()) ? 1 : 0.2;

    // Brute Force vulnerability (based on length and character set)
    const bruteForceVulnerability = Math.max(0, 1 - (password.length / 16));

    // Pattern Based vulnerability
    const patternVulnerability = /(.)\1{2,}/.test(password) ? 0.8 :  // Repeating characters
                                /123|abc|qwerty/.test(password.toLowerCase()) ? 0.9 : 0.3;

    // Rainbow Table vulnerability (based on complexity and length)
    const rainbowVulnerability = password.length < 8 ? 0.9 :
                                /^[a-zA-Z0-9]+$/.test(password) ? 0.7 : 0.4;

    // Social Engineering vulnerability (based on common personal info patterns)
    const socialVulnerability = /19\d{2}|20\d{2}|jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/i.test(password) ? 0.8 : 0.3;

    // Quantum Computing vulnerability (based on encryption strength needed)
    const quantumVulnerability = password.length < 12 ? 0.7 :
                                password.length < 16 ? 0.5 : 0.3;

    return [
      dictionaryVulnerability,
      bruteForceVulnerability,
      patternVulnerability,
      rainbowVulnerability,
      socialVulnerability,
      quantumVulnerability
    ].map(v => v * 100); // Convert to percentage
  };

  // Update analyzePassword function to include radar chart data
  const analyzePassword = async (pwdToAnalyze) => {
    setIsLoading(true);
    setError(null);
    
    try {
      const localAnalysis = calculateLocalAnalysis(pwdToAnalyze);
      setAnalysis(localAnalysis);
    } catch (err) {
      console.error('Analysis error:', err);
      setError(`Analysis Error: ${err.message}`);
    } finally {
      setIsLoading(false);
    }
  };

  const analyzeHash = async (hashToAnalyze, algorithm) => {
    setIsHashLoading(true);
    setHashError(null);
    
    try {
      // Use local hash analysis instead of server authentication
      const analysisResult = performLocalHashAnalysis(hashToAnalyze, algorithm);
      console.log('Hash analysis:', analysisResult);
      setHashAnalysis(analysisResult);
      
    } catch (err) {
      console.error('Hash analysis error:', err);
      setHashError(`Analysis Error: ${err.message}`);
      // Set default state on error
      setHashAnalysis({
        vulnerability_score: 0,
        confidence: 0,
        algorithm_details: {
          name: algorithm,
          bit_length: 0,
          quantum_resistant: false
        },
        risk_factors: [],
        recommendations: []
      });
    } finally {
      setIsHashLoading(false);
    }
  };

  const handlePasswordChange = (e) => {
    setPassword(e.target.value);
  };

  const handleAnalyzeClick = () => {
    analyzePassword(password);
  };

  const handleHashSubmit = () => {
    if (!hashValue) return;
    analyzeHash(hashValue, hashAlgorithm);
  };

  const handleGenerateHashes = () => {
    if (!password) return;
    const hashes = {
      md5: CryptoJS.MD5(password).toString(),
      sha1: CryptoJS.SHA1(password).toString(),
      sha256: CryptoJS.SHA256(password).toString(),
      sha3_256: CryptoJS.SHA3(password, { outputLength: 256 }).toString()
    };
    setGeneratedHashes(hashes);
  };

  const analyzeGeneratedHash = (hash, algorithm) => {
    setHashValue(hash);
    setHashAlgorithm(algorithm);
    setSelectedGeneratedHash({ hash, algorithm });
    analyzeHash(hash, algorithm);
  };

  const getStrengthColor = (score) => {
    score = Math.max(0, Math.min(100, score)); // Ensure score is between 0 and 100
    if (score >= 80) return '#4CAF50'; // Green
    if (score >= 60) return '#8BC34A'; // Light Green
    if (score >= 40) return '#FFC107'; // Amber
    if (score >= 20) return '#FF9800'; // Orange
    return '#F44336'; // Red
  };

  const getRiskLevelColor = (level) => {
    if (level === 'High') return '#F44336'; // Red
    if (level === 'Medium') return '#FF9800'; // Orange
    return '#4CAF50'; // Green
  };

  return (
    <div className="vulnerability-analysis-container">
      <button 
        onClick={() => navigate('/')}
        className="back-button"
      >
        &larr; Back to Main
      </button>
      <h1 className="main-title">Security Analysis Dashboard</h1>
      
      <div className="analysis-sections-container">
        {/* Only keep the Hash Analysis Section */}
        <div className="analysis-section hash-section">
          <div className="section-header">
            <h2>Hash Function Analysis</h2>
          </div>

          <div className="hash-tabs">
            <div className="tab-buttons">
              <button 
                className={`tab-button ${!generatedHashes ? 'active' : ''}`}
                onClick={() => setGeneratedHashes(null)}
              >
                Analyze Hash
              </button>
              <button 
                className={`tab-button ${generatedHashes ? 'active' : ''}`}
                onClick={() => setGeneratedHashes({})}
              >
                Generate Hash
              </button>
            </div>

            {!generatedHashes ? (
              <div className="hash-input-container">
                <div className="input-group">
                  <input
                    type="text"
                    value={hashValue}
                    onChange={(e) => setHashValue(e.target.value)}
                    placeholder="Enter hash value to analyze"
                    className="analysis-input"
                  />
                  <select
                    value={hashAlgorithm}
                    onChange={(e) => setHashAlgorithm(e.target.value)}
                    className="algorithm-select"
                  >
                    <option value="md5">MD5</option>
                    <option value="sha1">SHA-1</option>
                    <option value="sha256">SHA-256</option>
                    <option value="sha3_256">SHA3-256</option>
                    <option value="blake2b">BLAKE2b</option>
                  </select>
                </div>
                <button 
                  onClick={handleHashSubmit} 
                  className="analyze-button"
                  disabled={isHashLoading || !hashValue}
                >
                  {isHashLoading ? 'Analyzing...' : 'Analyze Hash'}
                </button>
              </div>
            ) : (
              <div className="hash-generation-container">
                <div className="input-group">
                  <input
                    type="text"
                    value={password}
                    onChange={handlePasswordChange}
                    placeholder="Enter text to generate hashes"
                    className="analysis-input"
                  />
                  <button
                    onClick={handleGenerateHashes}
                    className="generate-button"
                    disabled={!password}
                  >
                    Generate Hashes
                  </button>
                </div>

                {Object.keys(generatedHashes).length > 0 && (
                  <div className="generated-hashes">
                    {Object.entries(generatedHashes).map(([algo, hash]) => (
                      <div key={algo} className="hash-result-card">
                        <div className="hash-header">
                          <span className="hash-algorithm">{algo.toUpperCase()}</span>
                          <div className="hash-actions">
                            <button
                              onClick={() => analyzeGeneratedHash(hash, algo)}
                              className="action-button analyze"
                              title="Analyze this hash"
                            >
                              Analyze
                            </button>
                            <button
                              onClick={() => {
                                navigator.clipboard.writeText(hash);
                              }}
                              className="action-button copy"
                              title="Copy to clipboard"
                            >
                              Copy
                            </button>
                          </div>
                        </div>
                        <div className="hash-value">
                          <code>{hash}</code>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}
          </div>

          {hashError && <div className="error-message">{hashError}</div>}
          
          {isHashLoading && (
            <div className="loading-spinner">
              <div className="spinner"></div>
              <p>Analyzing hash...</p>
            </div>
          )}

          {hashAnalysis && !isHashLoading && (
            <div className="hash-analysis-results">
              <div className="vulnerability-assessment">
                <h3>Vulnerability Assessment</h3>
                <div className="vulnerability-meter">
                  <div 
                    className="vulnerability-bar"
                    style={{
                      width: `${(hashAnalysis.vulnerability_score || 0) * 100}%`,
                      backgroundColor: hashAnalysis.vulnerability_score > 0.7 ? '#F44336' :
                                     hashAnalysis.vulnerability_score > 0.4 ? '#FFC107' : '#4CAF50'
                    }}
                  ></div>
                </div>
                <div className="score-details">
                  <span>Vulnerability Score: </span>
                  <span className="score-value">
                    {((hashAnalysis.vulnerability_score || 0) * 100).toFixed(1)}%
                  </span>
                  <span className="confidence">
                    (Confidence: {((hashAnalysis.confidence || 0) * 100).toFixed(1)}%)
                  </span>
                </div>
              </div>

              <div className="algorithm-info">
                <h3>Algorithm Information</h3>
                <div className="info-grid">
                  <div className="info-card">
                    <span>Algorithm:</span>
                    <span>{hashAnalysis.algorithm_details?.name?.toUpperCase() || 'Unknown'}</span>
                  </div>
                  <div className="info-card">
                    <span>Bit Length:</span>
                    <span>{hashAnalysis.algorithm_details?.bit_length || 0} bits</span>
                  </div>
                  <div className="info-card">
                    <span>Quantum Resistant:</span>
                    <span className={hashAnalysis.algorithm_details?.quantum_resistant ? 'safe' : 'warning'}>
                      {hashAnalysis.algorithm_details?.quantum_resistant ? 'Yes' : 'No'}
                    </span>
                  </div>
                </div>
              </div>

              {hashAnalysis.risk_factors && hashAnalysis.risk_factors.length > 0 && (
                <div className="risk-factors">
                  <h3>Risk Factors</h3>
                  <div className="risk-grid">
                    {hashAnalysis.risk_factors.map((risk, index) => (
                      <div key={index} className={`risk-card ${risk.severity}`}>
                        <div className="risk-header">
                          <span className="risk-type">{risk.type}</span>
                          <span className={`severity-badge ${risk.severity}`}>
                            {risk.severity}
                          </span>
                        </div>
                        <p className="risk-description">{risk.description}</p>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {hashAnalysis.recommendations && hashAnalysis.recommendations.length > 0 && (
                <div className="recommendations">
                  <h3>Security Recommendations</h3>
                  <ul className="recommendations-list">
                    {hashAnalysis.recommendations.map((rec, index) => (
                      <li key={index} className="recommendation-item">{rec}</li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          )}
        </div>
      </div>

      <style jsx>{`
        .vulnerability-analysis-container {
          max-width: 900px;
          margin: 0 auto;
          padding: 2.5rem 1.5rem;
          min-height: 100vh;
          background-color: #f8f9fa;
        }
        .analysis-sections-container {
          display: flex;
          flex-direction: column;
          gap: 2.5rem;
          margin-top: 2rem;
        }
        .analysis-section.hash-section {
          background: white;
          border-radius: 16px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
          padding: 2.5rem 2rem;
          border: 1px solid #e0e0e0;
          margin: 0 auto;
        }
        .section-header {
          margin-bottom: 2rem;
          padding-bottom: 1rem;
          border-bottom: 2px solid #f0f0f0;
        }
        .section-header h2 {
          color: #262c42;
          font-size: 1.5rem;
          margin: 0;
        }
        .input-container, .hash-input-container {
          display: flex;
          flex-direction: column;
          gap: 1rem;
          margin-bottom: 2rem;
        }
        .input-group {
          display: flex;
          gap: 1rem;
        }
        .analysis-input {
          flex: 1;
          padding: 0.75rem 1rem;
          border: 2px solid #e0e0e0;
          border-radius: 8px;
          font-size: 1rem;
          transition: all 0.3s ease;
        }
        .analysis-input:focus {
          border-color: #262c42;
          outline: none;
          box-shadow: 0 0 0 2px rgba(38, 44, 66, 0.1);
        }
        .algorithm-select {
          min-width: 150px;
          padding: 0.75rem;
          border: 2px solid #e0e0e0;
          border-radius: 8px;
          font-size: 1rem;
          background: white;
          cursor: pointer;
        }
        .analyze-button, .generate-button {
          padding: 0.75rem 1.5rem;
          background: #262c42;
          color: white;
          border: none;
          border-radius: 8px;
          font-size: 1rem;
          cursor: pointer;
          transition: all 0.3s ease;
        }
        .analyze-button:hover:not(:disabled),
        .generate-button:hover:not(:disabled) {
          background: #1a1f2e;
          transform: translateY(-1px);
        }
        .analyze-button:disabled,
        .generate-button:disabled {
          background: #9e9e9e;
          cursor: not-allowed;
        }
        .metrics-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
          gap: 1rem;
          margin: 1.5rem 0;
        }
        .metric-card {
          background: #f8f9fa;
          padding: 1rem;
          border-radius: 8px;
          display: flex;
          justify-content: space-between;
          align-items: center;
        }
        .hash-tabs {
          margin-bottom: 2rem;
        }
        .tab-buttons {
          display: flex;
          gap: 1rem;
          margin-bottom: 1.5rem;
        }
        .tab-button {
          padding: 0.75rem 1.5rem;
          background: none;
          border: none;
          border-bottom: 2px solid transparent;
          color: #666;
          font-size: 1rem;
          cursor: pointer;
          transition: all 0.3s ease;
        }
        .tab-button.active {
          color: #262c42;
          border-bottom-color: #262c42;
        }
        .generated-hashes {
          display: grid;
          gap: 1rem;
          margin-top: 1.5rem;
        }
        .hash-result-card {
          background: #f8f9fa;
          border-radius: 8px;
          padding: 1rem;
        }
        .hash-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 0.75rem;
        }
        .hash-algorithm {
          font-weight: 600;
          color: #262c42;
        }
        .hash-actions {
          display: flex;
          gap: 0.5rem;
        }
        .action-button {
          padding: 0.25rem 0.75rem;
          border: none;
          border-radius: 4px;
          font-size: 0.875rem;
          cursor: pointer;
          transition: all 0.3s ease;
        }
        .action-button.analyze {
          background: #262c42;
          color: white;
        }
        .action-button.copy {
          background: #e0e0e0;
          color: #262c42;
        }
        .hash-value {
          background: white;
          padding: 0.75rem;
          border-radius: 4px;
          font-family: monospace;
          font-size: 0.875rem;
          overflow-x: auto;
        }
        .vulnerability-assessment {
          margin-bottom: 2rem;
        }
        .vulnerability-meter {
          height: 8px;
          background: #e0e0e0;
          border-radius: 4px;
          overflow: hidden;
          margin: 1rem 0;
        }
        .info-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
          gap: 1rem;
          margin-top: 1rem;
        }
        .info-card {
          background: #f8f9fa;
          padding: 1rem;
          border-radius: 8px;
          display: flex;
          justify-content: space-between;
          align-items: center;
        }
        .risk-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
          gap: 1rem;
          margin-top: 1rem;
        }
        .risk-card {
          padding: 1rem;
          border-radius: 8px;
          background: #f8f9fa;
        }
        .recommendations-list {
          list-style: none;
          padding: 0;
          margin: 1rem 0;
        }
        .recommendation-item {
          padding: 1rem;
          margin-bottom: 0.5rem;
          background: #f8f9fa;
          border-radius: 8px;
          border-left: 4px solid #262c42;
        }
        @media (min-width: 1024px) {
          .analysis-sections-container {
            grid-template-columns: 1fr 1fr;
          }
        }
        @media (max-width: 768px) {
          .input-group {
            flex-direction: column;
          }
          .hash-header {
            flex-direction: column;
            align-items: flex-start;
            gap: 0.5rem;
          }
          .hash-actions {
            width: 100%;
            justify-content: flex-end;
          }
        }
        .back-button {
          position: absolute;
          top: 20px;
          left: 20px;
          padding: 8px 16px;
          background-color: #262c42;
          color: white;
          border: none;
          border-radius: 8px;
          cursor: pointer;
          font-size: 14px;
          transition: all 0.3s ease;
        }
        .back-button:hover {
          background-color: #1a1f2e;
          transform: translateY(-1px);
        }
        .main-title {
          text-align: center;
          color: #262c42;
          margin: 1rem 0 2rem;
          font-size: 2rem;
        }
        .error-message {
          color: #f44336;
          padding: 1rem;
          background: #ffebee;
          border-radius: 8px;
          margin: 1rem 0;
        }
        .loading-spinner {
          display: flex;
          flex-direction: column;
          align-items: center;
          margin: 2rem 0;
        }
        .spinner {
          width: 40px;
          height: 40px;
          border: 4px solid #f3f3f3;
          border-top: 4px solid #262c42;
          border-radius: 50%;
          animation: spin 1s linear infinite;
        }
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
      `}</style>
    </div>
  );
};

export default VulnerabilityAnalysisPage; 