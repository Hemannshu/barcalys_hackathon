import React, { useState, useEffect, useCallback } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import './VulnerabilityAnalysisPage.css';
import CryptoJS from 'crypto-js';
import ForceGraph2D from 'react-force-graph-2d';

const calculateLocalAnalysis = (password) => {
  // Calculate entropy bits
  const charsetSize = (
    (/[a-z]/.test(password) ? 26 : 0) +
    (/[A-Z]/.test(password) ? 26 : 0) +
    (/[0-9]/.test(password) ? 10 : 0) +
    (/[^A-Za-z0-9]/.test(password) ? 32 : 0)
  );
  const entropyBits = Math.log2(Math.pow(charsetSize, password.length));
  
  // Calculate strength score
  let strengthScore = Math.min(100, Math.floor(entropyBits * 1.5));
  
  // Apply penalties
  if (/(.)\1{2,}/.test(password)) strengthScore -= 20;
  if (/[a-z]{4,}/.test(password)) strengthScore -= 15;
  if (/123|abc|qwerty/.test(password)) strengthScore -= 30;
  
  // Determine strength category
  let strengthCategory;
  if (strengthScore >= 80) strengthCategory = 'Very Strong';
  else if (strengthScore >= 60) strengthCategory = 'Strong';
  else if (strengthScore >= 40) strengthCategory = 'Moderate';
  else if (strengthScore >= 20) strengthCategory = 'Weak';
  else strengthCategory = 'Very Weak';
  
  // Calculate crack times
  const guessesPerSecond = {
    online: 100,  // 100 guesses per second for online attacks
    offline_fast: 1e10,  // 10 billion guesses per second for fast offline attacks
    offline_slow: 1e4    // 10,000 guesses per second for slow offline attacks
  };
  
  const possibleCombinations = Math.pow(charsetSize || 1, password.length || 1);
  const crackTimes = {};
  
  Object.entries(guessesPerSecond).forEach(([type, speed]) => {
    // Add some randomness to make it more realistic
    const variability = 0.2; // 20% variability
    const effectiveSpeed = speed * (1 + (Math.random() * 2 - 1) * variability);
    const seconds = possibleCombinations / (2 * effectiveSpeed);
    
    // Adjust time based on password complexity
    const complexityMultiplier = 1 + (
      (/[A-Z]/.test(password) ? 0.3 : 0) +
      (/[0-9]/.test(password) ? 0.3 : 0) +
      (/[^A-Za-z0-9]/.test(password) ? 0.4 : 0)
    );
    
    const adjustedSeconds = seconds * complexityMultiplier;
    
    crackTimes[type] = {
      seconds: adjustedSeconds,
      time_readable: formatTime(adjustedSeconds)
    };
  });
  
  // Identify patterns and vulnerabilities
  const patterns = [];
  const attackTypes = [];
  
  if (/(.)\1{2,}/.test(password)) {
    patterns.push({
      type: 'Repetition',
      pattern: 'Repeated characters',
      severity: 'high'
    });
  }
  
  if (/[a-z]{4,}/.test(password)) {
    patterns.push({
      type: 'Dictionary',
      pattern: 'Common word pattern',
      severity: 'medium'
    });
  }
  
  if (/123|abc|qwerty/.test(password)) {
    patterns.push({
      type: 'Sequence',
      pattern: 'Common sequence',
      severity: 'high'
    });
  }
  
  if (password.length < 8) {
    attackTypes.push({
      name: 'Brute Force',
      description: 'Password is too short and can be quickly brute forced',
      risk_level: 'High'
    });
  }
  
  if (/^[a-zA-Z]+$/.test(password)) {
    attackTypes.push({
      name: 'Dictionary Attack',
      description: 'Password contains only letters and may be vulnerable to dictionary attacks',
      risk_level: 'Medium'
    });
  }
  
  return {
    strength_score: Math.max(0, strengthScore),
    strength_category: strengthCategory,
    suggestions: [
      'Use a mix of character types',
      'Avoid common patterns and sequences',
      'Make the password longer',
      'Avoid repeated characters'
    ],
    details: {
      entropy_bits: entropyBits,
      crack_times: crackTimes,
      length: password.length,
      has_uppercase: /[A-Z]/.test(password),
      has_lowercase: /[a-z]/.test(password),
      has_numbers: /[0-9]/.test(password),
      has_symbols: /[^A-Za-z0-9]/.test(password),
      char_types: (
        (/[A-Z]/.test(password) ? 1 : 0) +
        (/[a-z]/.test(password) ? 1 : 0) +
        (/[0-9]/.test(password) ? 1 : 0) +
        (/[^A-Za-z0-9]/.test(password) ? 1 : 0)
      ),
      repeating_chars: (password.match(/(.)\1{2,}/g) || []).length
    },
    patterns,
    attack_types: attackTypes,
    is_local_analysis: true
  };
};

const formatTime = (seconds) => {
  if (seconds < 1e-9) return 'nano-seconds';
  if (seconds < 1e-6) return 'micro-seconds';
  if (seconds < 1e-3) return 'milli-seconds';
  if (seconds < 1) return `${(seconds * 1000).toFixed(2)} milliseconds`;
  if (seconds < 60) return `${seconds.toFixed(1)} seconds`;
  if (seconds < 3600) return `${(seconds / 60).toFixed(1)} minutes`;
  if (seconds < 86400) return `${(seconds / 3600).toFixed(1)} hours`;
  if (seconds < 31536000) return `${(seconds / 86400).toFixed(1)} days`;
  if (seconds < 31536000 * 100) return `${(seconds / 31536000).toFixed(1)} years`;
  return 'centuries';
};

// Add this function near the top with other utility functions
const performLocalHashAnalysis = (hash, algorithm) => {
  // Basic hash analysis without server
  const analysis = {
    vulnerability_score: 0,
    confidence: 0.85,
    algorithm_details: {
      name: algorithm,
      bit_length: getBitLength(algorithm),
      quantum_resistant: isQuantumResistant(algorithm)
    },
    risk_factors: [],
    recommendations: []
  };

  // Analyze hash characteristics
  if (algorithm === 'md5') {
    analysis.vulnerability_score = 0.8;
    analysis.risk_factors.push({
      type: 'Collision Vulnerability',
      severity: 'high',
      description: 'MD5 is cryptographically broken and susceptible to collision attacks.'
    });
    analysis.recommendations.push(
      'Migrate to a stronger hash algorithm like SHA-256 or BLAKE2b',
      'If possible, rehash existing data with a stronger algorithm'
    );
  } else if (algorithm === 'sha1') {
    analysis.vulnerability_score = 0.6;
    analysis.risk_factors.push({
      type: 'Theoretical Weakness',
      severity: 'medium',
      description: 'SHA-1 has known theoretical weaknesses and is not recommended for new applications.'
    });
    analysis.recommendations.push(
      'Consider upgrading to SHA-256 or newer hash functions',
      'Monitor for any new vulnerabilities in SHA-1'
    );
  } else if (algorithm === 'sha256') {
    analysis.vulnerability_score = 0.2;
    analysis.risk_factors.push({
      type: 'Quantum Computing',
      severity: 'low',
      description: 'While currently secure, may be vulnerable to future quantum computing attacks.'
    });
    analysis.recommendations.push(
      'Consider quantum-resistant algorithms for long-term security',
      'Implement regular security reviews'
    );
  } else if (algorithm === 'sha3_256') {
    analysis.vulnerability_score = 0.1;
    analysis.risk_factors.push({
      type: 'Implementation',
      severity: 'low',
      description: 'Strong algorithm, but ensure proper implementation and salt usage.'
    });
    analysis.recommendations.push(
      'Ensure proper implementation of the algorithm',
      'Use appropriate salt values'
    );
  } else if (algorithm === 'blake2b') {
    analysis.vulnerability_score = 0.1;
    analysis.risk_factors.push({
      type: 'Best Practice',
      severity: 'low',
      description: 'Modern and secure, but ensure proper implementation.'
    });
    analysis.recommendations.push(
      'Maintain up-to-date implementations',
      'Follow security best practices for key handling'
    );
  }

  // Validate hash format
  const expectedLength = getExpectedLength(algorithm);
  if (!isValidHashFormat(hash, algorithm)) {
    analysis.risk_factors.push({
      type: 'Format Error',
      severity: 'high',
      description: `Invalid hash format for ${algorithm.toUpperCase()}. Expected length: ${expectedLength} characters.`
    });
    analysis.recommendations.push('Verify the hash was generated correctly');
    analysis.vulnerability_score = 1.0;
  }

  return analysis;
};

// Helper functions for local hash analysis
const getBitLength = (algorithm) => {
  const bitLengths = {
    md5: 128,
    sha1: 160,
    sha256: 256,
    sha3_256: 256,
    blake2b: 512
  };
  return bitLengths[algorithm] || 256;
};

const isQuantumResistant = (algorithm) => {
  return ['sha3_256', 'blake2b'].includes(algorithm);
};

const getExpectedLength = (algorithm) => {
  const lengths = {
    md5: 32,
    sha1: 40,
    sha256: 64,
    sha3_256: 64,
    blake2b: 128
  };
  return lengths[algorithm] || 64;
};

const isValidHashFormat = (hash, algorithm) => {
  const expectedLength = getExpectedLength(algorithm);
  const hexRegex = /^[0-9a-fA-F]+$/;
  return hash.length === expectedLength && hexRegex.test(hash);
};

const VulnerabilityAnalysisPage = () => {
  const location = useLocation();
  const navigate = useNavigate();
  
  // Initialize states with data from navigation if available
  const [password, setPassword] = useState(location.state?.analysisData?.password || '');
  const [analysis, setAnalysis] = useState(location.state?.analysisData ? {
    strength_score: location.state.analysisData.score || 0,
    strength_category: location.state.analysisData.category || 'Unknown',
    confidence: location.state.analysisData.confidence || 0,
    details: {
      entropy: location.state.analysisData.entropy || 0,
      length: location.state.analysisData.features?.length || 0,
      has_upper: location.state.analysisData.features?.has_upper || false,
      has_lower: location.state.analysisData.features?.has_lower || false,
      has_digit: location.state.analysisData.features?.has_digit || false,
      has_special: location.state.analysisData.features?.has_special || false,
      char_types: location.state.analysisData.features?.char_types || 0,
      repeating_chars: 0
    },
    patterns: location.state.analysisData.patterns || [],
    crack_times: location.state.analysisData.crack_times || {}
  } : {
    strength_score: 0,
    strength_category: 'Not Analyzed',
    confidence: 0,
    details: {
      entropy: 0,
      length: 0,
      has_upper: false,
      has_lower: false,
      has_digit: false,
      has_special: false,
      char_types: 0,
      repeating_chars: 0
    },
    patterns: [],
    crack_times: {}
  });
  
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  
  // Hash analysis states
  const [hashValue, setHashValue] = useState('');
  const [hashAlgorithm, setHashAlgorithm] = useState('sha256');
  const [generatedHashes, setGeneratedHashes] = useState(null);
  const [selectedGeneratedHash, setSelectedGeneratedHash] = useState(null);
  const [hashAnalysis, setHashAnalysis] = useState({
    vulnerability_score: 0,
    confidence: 0,
    algorithm_details: {
      name: '',
      bit_length: 0,
      quantum_resistant: false
    },
    risk_factors: [],
    recommendations: []
  });
  const [isHashLoading, setIsHashLoading] = useState(false);
  const [hashError, setHashError] = useState(null);

  // If no password is provided, redirect back to main page
  useEffect(() => {
    if (!location.state?.analysisData?.password) {
      navigate('/');
    }
  }, [location.state, navigate]);

  // Only call analyzePassword if we don't have analysis data from navigation
  useEffect(() => {
    if (password && !location.state?.analysisData) {
      analyzePassword(password);
    }
  }, [password, location.state]);

  const analyzePassword = async (pwdToAnalyze) => {
    setIsLoading(true);
    setError(null);
    
    try {
      const token = localStorage.getItem('token');
      if (!token) {
        setError('Authentication required. Please log in.');
        setIsLoading(false);
        return;
      }
      
      const response = await fetch('http://localhost:5000/api/analyze-password', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`
        },
        body: JSON.stringify({ password: pwdToAnalyze })
      });
      
      if (!response.ok) {
        throw new Error(`Server Error (${response.status})`);
      }
      
      const data = await response.json();
      console.log('Backend response:', data);
      
      const analysisResult = {
        strength_score: typeof data.score === 'number' ? parseFloat(data.score) : 0,
        strength_category: data.category || 'Unknown',
        confidence: typeof data.confidence === 'number' ? parseFloat(data.confidence) : 0,
        details: {
          entropy: typeof data.entropy === 'number' ? parseFloat(data.entropy) : 0,
          length: data.features?.length || pwdToAnalyze.length,
          has_upper: Boolean(data.features?.has_upper),
          has_lower: Boolean(data.features?.has_lower),
          has_digit: Boolean(data.features?.has_digit),
          has_special: Boolean(data.features?.has_special),
          char_types: Number(data.features?.char_types || 0),
          repeating_chars: (pwdToAnalyze.match(/(.)\1{2,}/g) || []).length
        },
        patterns: Array.isArray(data.patterns) ? data.patterns : [],
        crack_times: data.crack_times || {}
      };
      
      setAnalysis(analysisResult);
      
    } catch (err) {
      console.error('Analysis error:', err);
      setError(`Analysis Error: ${err.message}`);
    } finally {
      setIsLoading(false);
    }
  };

  const analyzeHash = async (hashToAnalyze, algorithm) => {
    setIsHashLoading(true);
    setHashError(null);
    
    try {
      const token = localStorage.getItem('token');
      if (!token) {
        setHashError('Authentication required. Please log in.');
        setIsHashLoading(false);
        return;
      }

      let analysisResult;
      try {
        const response = await fetch('http://localhost:5000/api/analyze-hash', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({ hash: hashToAnalyze, algorithm })
        });

        if (!response.ok) {
          throw new Error(`Server Error (${response.status})`);
        }

        const data = await response.json();
        console.log('Hash analysis response:', data);

        // Map backend response to frontend structure
        analysisResult = {
          vulnerability_score: Number(data.vulnerability_score || 0),
          confidence: Number(data.confidence || 0),
          algorithm_details: {
            name: data.algorithm_details?.name || algorithm,
            bit_length: Number(data.algorithm_details?.bit_length || 0),
            quantum_resistant: Boolean(data.algorithm_details?.quantum_resistant)
          },
          risk_factors: Array.isArray(data.risk_factors) ? data.risk_factors : [],
          recommendations: Array.isArray(data.recommendations) ? data.recommendations : []
        };
      } catch (error) {
        console.error('Server analysis failed:', error);
        // Fallback to local analysis
        analysisResult = performLocalHashAnalysis(hashToAnalyze, algorithm);
      }

      console.log('Final hash analysis:', analysisResult);
      setHashAnalysis(analysisResult);
      
    } catch (err) {
      console.error('Hash analysis error:', err);
      setHashError(`Analysis Error: ${err.message}`);
      // Set default state on error
      setHashAnalysis({
        vulnerability_score: 0,
        confidence: 0,
        algorithm_details: {
          name: algorithm,
          bit_length: 0,
          quantum_resistant: false
        },
        risk_factors: [],
        recommendations: []
      });
    } finally {
      setIsHashLoading(false);
    }
  };

  const handlePasswordChange = (e) => {
    setPassword(e.target.value);
  };

  const handleAnalyzeClick = () => {
    analyzePassword(password);
  };

  const handleHashSubmit = () => {
    if (!hashValue) return;
    analyzeHash(hashValue, hashAlgorithm);
  };

  const handleGenerateHashes = () => {
    if (!password) return;
    const hashes = {
      md5: CryptoJS.MD5(password).toString(),
      sha1: CryptoJS.SHA1(password).toString(),
      sha256: CryptoJS.SHA256(password).toString(),
      sha3_256: CryptoJS.SHA3(password, { outputLength: 256 }).toString()
    };
    setGeneratedHashes(hashes);
  };

  const analyzeGeneratedHash = (hash, algorithm) => {
    setHashValue(hash);
    setHashAlgorithm(algorithm);
    setSelectedGeneratedHash({ hash, algorithm });
    analyzeHash(hash, algorithm);
  };

  const getStrengthColor = (score) => {
    score = Math.max(0, Math.min(100, score)); // Ensure score is between 0 and 100
    if (score >= 80) return '#4CAF50'; // Green
    if (score >= 60) return '#8BC34A'; // Light Green
    if (score >= 40) return '#FFC107'; // Amber
    if (score >= 20) return '#FF9800'; // Orange
    return '#F44336'; // Red
  };

  const getRiskLevelColor = (level) => {
    if (level === 'High') return '#F44336'; // Red
    if (level === 'Medium') return '#FF9800'; // Orange
    return '#4CAF50'; // Green
  };

  return (
    <div className="vulnerability-analysis-container" style={{ backgroundColor: '#f0f8ff' }}>
    <button 
        onClick={() => navigate('/')}
        className="back-button"
      >
        &larr; Back to Main
      </button>
      <h1 className="main-title">Security Analysis Dashboard</h1>
      
      <div className="analysis-tabs">
        {/* Password Analysis Section */}
        <div className="analysis-section password-section">
          <div className="section-header">
            <h2>
              <i className="fas fa-key"></i>
              Password Vulnerability Analysis
            </h2>
          </div>
          
          <div className="password-input-section">
            <input
              type="text"
              value={password}
              onChange={handlePasswordChange}
              placeholder="Enter password to analyze"
              className="password-input"
            />
            <button 
              onClick={handleAnalyzeClick} 
              className="analyze-button"
              disabled={isLoading || !password}
            >
              {isLoading ? 'Analyzing...' : 'Analyze Password'}
            </button>
          </div>

          {error && <div className="error-message">{error}</div>}
          
          {isLoading && (
            <div className="loading-spinner">
              <div className="spinner"></div>
              <p>Analyzing password strength...</p>
            </div>
          )}

          {analysis && !isLoading && (
            <div className="analysis-results">
              <div className="strength-meter">
                <h2>Password Strength</h2>
                <div className="strength-bar-container">
                  <div 
                    className="strength-bar" 
                    style={{ 
                      width: `${Math.max(1, Math.min(100, analysis.strength_score * 100))}%`,
                      backgroundColor: getStrengthColor(analysis.strength_score * 100)
                    }}
                  ></div>
                </div>
                <div className="strength-score">
                  <span>Score: </span>
                  <span style={{ color: getStrengthColor(analysis.strength_score * 100) }}>
                    {Math.round(analysis.strength_score * 100)}/100
                  </span>
                  <span> ({analysis.strength_category})</span>
                  {analysis?.confidence && (
                    <span className="confidence-score">
                      {' '}• ML Confidence: {(analysis.confidence * 100).toFixed(3)}%
                    </span>
                  )}
                </div>
                <div className="password-metrics">
                  <div className="metric-item">
                    <span>Length:</span>
                    <span>{analysis.details.length} characters</span>
                  </div>
                  <div className="metric-item">
                    <span>Entropy:</span>
                    <span>{analysis.details.entropy?.toFixed(2) || '0.00'} bits</span>
                  </div>
                  <div className="metric-item">
                    <span>Character Types:</span>
                    <span>{analysis.details.char_types}/4</span>
                  </div>
                  {analysis.details.repeating_chars > 0 && (
                    <div className="metric-item warning">
                      <span>Repeating Characters: </span>
                      <span>{analysis.details.repeating_chars}</span>
                    </div>
                  )}
                </div>
              </div>
              
              {/* Attack Methods Analysis */}
              <div className="attack-methods">
                <h2>Attack Methods Analysis</h2>
                <div className="attack-grid">
                  {analysis.crack_times && typeof analysis.crack_times === 'object' && Object.entries(analysis.crack_times).map(([method, data]) => {
                    // Skip if data is null or undefined
                    if (!data) return null;
                    
                    // Handle Infinity values for display
                    const timeReadable = data.time_readable || 
                      (data.seconds === Infinity ? 'centuries' : 
                       data.seconds === -Infinity ? 'instant' : 
                       formatTime(data.seconds));

                    return (
                      <div key={method} className="attack-card">
                        <h3>{method.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ')}</h3>
                        <div className="attack-details">
                          <div className="time-to-crack">
                            <span className="label">Time to Crack:</span>
                            <span className="value">{timeReadable}</span>
                          </div>
                          {typeof data.entropy_contribution === 'number' && (
                            <div className="entropy-contribution">
                              <span className="label">Entropy Contribution:</span>
                              <div className="entropy-bar">
                                <div 
                                  className="entropy-fill"
                                  style={{ width: `${data.entropy_contribution}%` }}
                                />
                              </div>
                              <span className="value">{data.entropy_contribution.toFixed(1)}%</span>
                            </div>
                          )}
                          {data.description && (
                            <p className="attack-description">{data.description}</p>
                          )}
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
              
              {/* Password Patterns */}
              {analysis.patterns && analysis.patterns.length > 0 && (
                <div className="patterns-section">
                  <h2>Detected Patterns</h2>
                  <div className="patterns-grid">
                    {analysis.patterns.map((pattern, index) => (
                      <div key={index} className="pattern-card">
                        <div className="pattern-header">
                          <h3>{pattern.type}</h3>
                          <span className={`severity-badge ${pattern.severity.toLowerCase()}`}>
                            {pattern.severity}
                          </span>
                        </div>
                        <p className="pattern-value">{pattern.pattern}</p>
                      </div>
                    ))}
                  </div>
                </div>
              )}
              
              {/* Character Composition */}
              {/* <div className="char-composition-section">
                <h2>Character Composition</h2>
                <div className="char-types-grid">
                  <div className={`char-type ${/[A-Z]/.test(password) ? 'present' : ''}`}>
                    <span className="char-type-label">ABC</span>
                    <span className="char-type-status">{/[A-Z]/.test(password) ? '✓' : '×'}</span>
                    <span className="char-type-count">
                      {(password.match(/[A-Z]/g) || []).length} uppercase
                    </span>
                  </div>
                  <div className={`char-type ${/[a-z]/.test(password) ? 'present' : ''}`}>
                    <span className="char-type-label">abc</span>
                    <span className="char-type-status">{/[a-z]/.test(password) ? '✓' : '×'}</span>
                    <span className="char-type-count">
                      {(password.match(/[a-z]/g) || []).length} lowercase
                    </span>
                  </div>
                  <div className={`char-type ${/[0-9]/.test(password) ? 'present' : ''}`}>
                    <span className="char-type-label">123</span>
                    <span className="char-type-status">{/[0-9]/.test(password) ? '✓' : '×'}</span>
                    <span className="char-type-count">
                      {(password.match(/[0-9]/g) || []).length} numbers
                    </span>
                  </div>
                  <div className={`char-type ${/[^A-Za-z0-9]/.test(password) ? 'present' : ''}`}>
                    <span className="char-type-label">#@!</span>
                    <span className="char-type-status">{/[^A-Za-z0-9]/.test(password) ? '✓' : '×'}</span>
                    <span className="char-type-count">
                      {(password.match(/[^A-Za-z0-9]/g) || []).length} special
                    </span>
                  </div>
                </div>
                <div className="composition-summary">
                  <div className="summary-item">
                    <span>Total Length:</span>
                    <span>{password.length} characters</span>
                  </div>
                  <div className="summary-item">
                    <span>Character Types Used:</span>
                    <span>{[
                      /[A-Z]/.test(password),
                      /[a-z]/.test(password),
                      /[0-9]/.test(password),
                      /[^A-Za-z0-9]/.test(password)
                    ].filter(Boolean).length} of 4</span>
                  </div>
                  {/(.)\1{2,}/.test(password) && (
                    <div className="summary-item warning">
                      <span>Warning:</span>
                      <span>Contains repeating characters</span>
                    </div>
                  )}
                </div>
              </div> */}

              {/* New ML Analysis Section */}
              <div className="ml-analysis-section">
                <h2>Machine Learning Analysis</h2>
                
                <div className="ml-metrics-grid">
                  {/* ML Confidence Score */}
                  <div className="ml-metric-card">
                    <h3>ML Confidence</h3>
                    <div className="ml-metric-value" style={{
                      color: (analysis.confidence || 0) > 0.7 ? '#4CAF50' : 
                             (analysis.confidence || 0) > 0.4 ? '#FFC107' : '#F44336'
                    }}>
                      {((analysis.confidence || 0) * 100).toFixed(3)}%
                    </div>
                    <div className="ml-metric-description">
                      Model's confidence in its analysis
                    </div>
                  </div>

                  {/* Strength Score */}
                  <div className="ml-metric-card">
                    <h3>ML Strength Assessment</h3>
                    <div className="ml-metric-value" style={{
                      color: (analysis.strength_score || 0) >= 0.9 ? '#4CAF50' :  // Very Strong
                             (analysis.strength_score || 0) >= 0.7 ? '#8BC34A' :  // Strong
                             (analysis.strength_score || 0) >= 0.5 ? '#FFC107' :  // Moderate
                             (analysis.strength_score || 0) >= 0.3 ? '#FF9800' :  // Weak
                             '#F44336'                                            // Very Weak
                    }}>
                      {((analysis.strength_score || 0) * 10).toFixed(1)}/10
                    </div>
                    <div className="strength-category">
                      {(() => {
                        const score = analysis.strength_score || 0;
                        if (score >= 0.9) return 'Very Strong';
                        if (score >= 0.7) return 'Strong';
                        if (score >= 0.5) return 'Moderate';
                        if (score >= 0.3) return 'Weak';
                        return 'Very Weak';
                      })()}
                    </div>
                    <div className="ml-metric-description">
                      Comprehensive strength assessment based on length, complexity, patterns, and entropy
                    </div>
                    <div className="strength-details">
                      <div className="detail-item">
                        <span>Length Score:</span>
                        <span>{Math.min(30, Math.max(0, analysis.details.length * 2.5))}%</span>
                      </div>
                      <div className="detail-item">
                        <span>Character Mix:</span>
                        <span>{Math.min(30, analysis.details.char_types * 7.5)}%</span>
                      </div>
                      <div className="detail-item">
                        <span>Complexity:</span>
                        <span>{Math.min(20, (analysis.details.char_types - 1) * 5)}%</span>
                      </div>
                      <div className="detail-item">
                        <span>Entropy Bonus:</span>
                        <span>{Math.min(20, (analysis.details.entropy || 0) / 4)}%</span>
                      </div>
                    </div>
                  </div>

                  {/* Entropy Analysis */}
                  <div className="ml-metric-card">
                    <h3>Entropy Analysis</h3>
                    <div className="ml-metric-value">
                      {(analysis.details.entropy || 0).toFixed(2)} bits
                    </div>
                    <div className="entropy-bar">
                      <div 
                        className="entropy-fill"
                        style={{ width: `${Math.min(100, (analysis.details.entropy || 0) * 2)}%` }}
                      />
                    </div>
                    <div className="ml-metric-description">
                      Password randomness score
                    </div>
                  </div>

                  {/* Pattern Detection */}
                  {analysis.details.repeating_chars > 0 && (
                    <div className="ml-metric-card warning">
                      <h3>Pattern Warning</h3>
                      <div className="ml-metric-value">
                        {analysis.details.repeating_chars} repeating characters
                      </div>
                      <div className="ml-metric-description">
                        Repeated characters make your password weaker
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}
        </div>

        {/* Hash Analysis Section */}
        <div className="analysis-section hash-section">
          <div className="section-header">
            <h2>
              <i className="fas fa-hashtag"></i>
              Hash Function Analysis
            </h2>
          </div>

          <div className="hash-tabs">
            <div className="tab-buttons">
              <button 
                className={`tab-button ${!generatedHashes ? 'active' : ''}`}
                onClick={() => setGeneratedHashes(null)}
              >
                Analyze Hash
              </button>
              <button 
                className={`tab-button ${generatedHashes ? 'active' : ''}`}
                onClick={() => setGeneratedHashes({})}
              >
                Generate Hash
              </button>
            </div>

            {!generatedHashes ? (
              // Original Hash Analysis Input
              <div className="hash-input-section">
                <div className="hash-input-group">
                  <input
                    type="text"
                    value={hashValue}
                    onChange={(e) => setHashValue(e.target.value)}
                    placeholder="Enter hash value to analyze"
                    className="hash-input"
                  />
                  <select
                    value={hashAlgorithm}
                    onChange={(e) => setHashAlgorithm(e.target.value)}
                    className="algorithm-select"
                  >
                    <option value="md5">MD5</option>
                    <option value="sha1">SHA-1</option>
                    <option value="sha256">SHA-256</option>
                    <option value="sha3_256">SHA3-256</option>
                    <option value="blake2b">BLAKE2b</option>
                  </select>
                </div>
                <button 
                  onClick={handleHashSubmit} 
                  className="analyze-button"
                  disabled={isHashLoading || !hashValue}
                >
                  {isHashLoading ? 'Analyzing...' : 'Analyze Hash'}
                </button>
              </div>
            ) : (
              // Hash Generation Section
              <div className="hash-generation-section">
                <div className="hash-input-group">
                  <input
                    type="text"
                    value={password}
                    onChange={handlePasswordChange}
                    placeholder="Enter text to generate hashes"
                    className="hash-input"
                  />
                  <button
                    onClick={handleGenerateHashes}
                    className="generate-button"
                    disabled={!password}
                  >
                    Generate Hashes
                  </button>
                </div>

                {Object.keys(generatedHashes).length > 0 && (
                  <div className="generated-hashes-grid">
                    {Object.entries(generatedHashes).map(([algo, hash]) => (
                      <div key={algo} className="hash-card">
                        <div className="hash-card-header">
                          <span className="hash-algorithm">{algo.toUpperCase()}</span>
                          <div className="hash-actions">
                            <button
                              onClick={() => analyzeGeneratedHash(hash, algo)}
                              className="analyze-hash-button"
                              title="Analyze this hash"
                            >
                              <i className="fas fa-search"></i> Analyze
                            </button>
                            <button
                              onClick={() => {
                                navigator.clipboard.writeText(hash);
                              }}
                              className="copy-button"
                              title="Copy to clipboard"
                            >
                              <i className="fas fa-copy"></i>
                            </button>
                          </div>
                        </div>
                        <div className="hash-value">
                          <code>{hash}</code>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}
          </div>

          {hashError && <div className="error-message">{hashError}</div>}
          
          {isHashLoading && (
            <div className="loading-spinner">
              <div className="spinner"></div>
              <p>Analyzing hash...</p>
            </div>
          )}

          {hashAnalysis && !isHashLoading && (
            <div className="hash-analysis-results">
              {/* Vulnerability Score */}
              <div className="hash-score-section">
                <h3>Vulnerability Assessment</h3>
                <div className="vulnerability-meter">
                  <div 
                    className="vulnerability-bar"
                    style={{
                      width: `${(hashAnalysis.vulnerability_score || 0) * 100}%`,
                      backgroundColor: hashAnalysis.vulnerability_score > 0.7 ? '#F44336' :
                                     hashAnalysis.vulnerability_score > 0.4 ? '#FFC107' : '#4CAF50'
                    }}
                  ></div>
                </div>
                <div className="score-details">
                  <span>Vulnerability Score: </span>
                  <span className="score-value">
                    {((hashAnalysis.vulnerability_score || 0) * 100).toFixed(1)}%
                  </span>
                  <span className="confidence">
                    (Confidence: {((hashAnalysis.confidence || 0) * 100).toFixed(3)}%)
                  </span>
                </div>
              </div>

              {/* Algorithm Details */}
              <div className="algorithm-details">
                <h3>Algorithm Information</h3>
                <div className="details-grid">
                  <div className="detail-item">
                    <span>Algorithm:</span>
                    <span>{hashAnalysis.algorithm_details?.name?.toUpperCase() || 'Unknown'}</span>
                  </div>
                  <div className="detail-item">
                    <span>Bit Length:</span>
                    <span>{hashAnalysis.algorithm_details?.bit_length || 0} bits</span>
                  </div>
                  <div className="detail-item">
                    <span>Quantum Resistant:</span>
                    <span className={hashAnalysis.algorithm_details?.quantum_resistant ? 'safe' : 'warning'}>
                      {hashAnalysis.algorithm_details?.quantum_resistant ? 'Yes' : 'No'}
                    </span>
                  </div>
                </div>
              </div>

              {/* Risk Factors */}
              {hashAnalysis.risk_factors && hashAnalysis.risk_factors.length > 0 && (
                <div className="risk-factors">
                  <h3>Risk Factors</h3>
                  <div className="risks-grid">
                    {hashAnalysis.risk_factors.map((risk, index) => (
                      <div key={index} className={`risk-card ${risk.severity}`}>
                        <div className="risk-header">
                          <span className="risk-type">{risk.type}</span>
                          <span className={`severity-badge ${risk.severity}`}>
                            {risk.severity}
                          </span>
                        </div>
                        <p className="risk-description">{risk.description}</p>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Recommendations */}
              {hashAnalysis.recommendations && hashAnalysis.recommendations.length > 0 && (
                <div className="recommendations">
                  <h3>Security Recommendations</h3>
                  <ul className="recommendations-list">
                    {hashAnalysis.recommendations.map((rec, index) => (
                      <li key={index} className="recommendation-item">{rec}</li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          )}
        </div>
      </div>

      <style jsx>{`
        .vulnerability-analysis-container {
          max-width: 1200px;
          margin: 0 auto;
          padding: 2rem;
          min-height: 100vh;
          position: relative;
        }

        .back-button {
          position: absolute;
          top: 20px;
          left: 20px;
          padding: 8px 16px;
          background-color: #262c42;
          color: white;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-size: 14px;
          transition: background-color 0.3s ease;
        }

        .back-button:hover {
          background-color: #1a1f2e;
        }

        .main-title {
          text-align: center;
          color: #262c42;
          margin-bottom: 2rem;
          font-size: 2rem;
        }

        .analysis-tabs {
          display: grid;
          grid-template-columns: 1fr;
          gap: 2rem;
        }

        .analysis-section {
          background: #fff;
          border-radius: 10px;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
          padding: 2rem;
          margin-bottom: 2rem;
        }

        .section-header {
          border-bottom: 2px solid #e0e0e0;
          margin-bottom: 1.5rem;
          padding-bottom: 1rem;
        }

        .section-header h2 {
          color: #262c42 ;
          display: flex;
          align-items: center;
          gap: 0.5rem;
          margin: 0;
        }

        .section-header i {
          font-size: 1.5rem;
        }

        .password-section {
          border-top: 4px solid #262c42;
        }

        .hash-section {
          border-top: 4px solidrgb(66, 72, 92);
        }

        .hash-tabs {
          margin-bottom: 2rem;
        }

        .tab-buttons {
          display: flex;
          gap: 1rem;
          margin-bottom: 1.5rem;
        }

        .tab-button {
          padding: 0.75rem 1.5rem;
          background: none;
          border: none;
          border-bottom: 2px solid transparent;
          color: #666;
          font-size: 1rem;
          cursor: pointer;
          transition: all 0.3s ease;
        }

        .tab-button:hover {
          color: #262c42;
        }

        .tab-button.active {
          color: #262c42;
          border-bottom-color: #262c42;
        }

        .hash-input-section {
          display: flex;
          flex-direction: column;
          gap: 1rem;
          margin-bottom: 1.5rem;
        }

        .hash-input-group {
          display: flex;
          gap: 1rem;
        }

        .hash-input {
          flex: 1;
          padding: 0.75rem;
          border: 2px solid #e0e0e0;
          border-radius: 4px;
          font-size: 1rem;
          transition: border-color 0.3s ease;
        }

        .hash-input:focus {
          border-color: #262c42;
          outline: none;
        }

        .algorithm-select {
          min-width: 150px;
          padding: 0.75rem;
          border: 2px solid #e0e0e0;
          border-radius: 4px;
          font-size: 1rem;
          background: #fff;
          cursor: pointer;
        }

        .algorithm-select:focus {
          border-color: #262c42;
          outline: none;
        }

        .analyze-button {
          padding: 0.75rem 1.5rem;
          background: #262c42;
          color: white;
          border: none;
          border-radius: 4px;
          font-size: 1rem;
          cursor: pointer;
          transition: background-color 0.3s ease;
        }

        .analyze-button:hover:not(:disabled) {
          background: #262c42;
        }

        .analyze-button:disabled {
          background: #9e9e9e;
          cursor: not-allowed;
        }

        .vulnerability-meter {
          height: 10px;
          background: #e0e0e0;
          border-radius: 5px;
          overflow: hidden;
          margin: 1rem 0;
        }

        .vulnerability-bar {
          height: 100%;
          transition: width 0.3s ease, background-color 0.3s ease;
        }

        .score-details {
          display: flex;
          align-items: center;
          gap: 1rem;
          font-size: 1.1rem;
        }

        .score-value {
          font-weight: 600;
          color: #262c42;
        }

        .confidence {
          color: #666;
          font-size: 0.9rem;
        }

        .details-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
          gap: 1rem;
          margin-top: 1rem;
        }

        .detail-item {
          display: flex;
          justify-content: space-between;
          padding: 1rem;
          background: #f5f5f5;
          border-radius: 4px;
          border-left: 4px solid #262c42;
        }

        .risks-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
          gap: 1rem;
          margin-top: 1rem;
        }

        .risk-card {
          padding: 1rem;
          border-radius: 4px;
          background: #f5f5f5;
        }

        .risk-card.high { border-left: 4px solid #f44336; }
        .risk-card.medium { border-left: 4px solid #ffc107; }
        .risk-card.low { border-left: 4px solid #4caf50; }

        .risk-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 0.5rem;
        }

        .severity-badge {
          padding: 0.25rem 0.75rem;
          border-radius: 12px;
          font-size: 0.8rem;
          font-weight: 500;
          text-transform: uppercase;
        }

        .severity-badge.high {
          background: #ffebee;
          color: #f44336;
        }

        .severity-badge.medium {
          background: #fff8e1;
          color: #ffc107;
        }

        .severity-badge.low {
          background: #e8f5e9;
          color: #4caf50;
        }

        .recommendations-list {
          list-style: none;
          padding: 0;
          margin: 1rem 0;
        }

        .recommendation-item {
          padding: 1rem;
          margin-bottom: 0.5rem;
          background: #f5f5f5;
          border-radius: 4px;
          border-left: 4px solid #262c42;
        }

        .safe { color: #4caf50; }
        .warning { color: #f44336; }

        @media (min-width: 1024px) {
          .analysis-tabs {
            grid-template-columns: 1fr 1fr;
          }
        }

        @media (max-width: 768px) {
          .hash-input-group {
            flex-direction: column;
          }

          .algorithm-select {
            width: 100%;
          }
        }

        .button-group {
          display: flex;
          gap: 1rem;
          margin-top: 1rem;
        }

        .generate-hash-button {
          padding: 0.75rem 1.5rem;
          background: #2962ff;
          color: white;
          border: none;
          border-radius: 4px;
          font-size: 1rem;
          cursor: pointer;
          transition: background-color 0.3s ease;
        }

        .generate-hash-button:hover:not(:disabled) {
          background: #262c42;
        }

        .generate-hash-button:disabled {
          background: #9e9e9e;
          cursor: not-allowed;
        }

        .generated-hashes-section {
          margin-top: 2rem;
          padding: 1.5rem;
          background: #f8f9fa;
          border-radius: 8px;
          border: 1px solid #e0e0e0;
        }

        .generated-hashes-section h3 {
          margin: 0 0 1rem 0;
          color:rgb(32, 37, 56);
        }

        .hash-grid {
          display: grid;
          gap: 1rem;
        }

        .hash-item {
          background: white;
          padding: 1rem;
          border-radius: 4px;
          border: 1px solid #e0e0e0;
        }

        .hash-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 0.5rem;
        }

        .hash-algorithm {
          font-weight: 600;
          color: #262c42;
        }

        .analyze-hash-button {
          padding: 0.25rem 0.75rem;
          background: #262c42;
          color: white;
          border: none;
          border-radius: 4px;
          font-size: 0.875rem;
          cursor: pointer;
          transition: background-color 0.3s ease;
        }

        .analyze-hash-button:hover {
          background: #262c42;
        }

        .hash-value {
          display: flex;
          align-items: center;
          gap: 0.5rem;
          background: #f5f5f5;
          padding: 0.5rem;
          border-radius: 4px;
          font-family: monospace;
          font-size: 0.875rem;
          overflow-x: auto;
        }

        .hash-value code {
          flex: 1;
          overflow-x: auto;
          white-space: nowrap;
        }

        .copy-button {
          padding: 0.25rem;
          background: none;
          border: none;
          color: #666;
          cursor: pointer;
          transition: color 0.3s ease;
        }

        .copy-button:hover {
          color: #262c42;
        }

        @media (max-width: 768px) {
          .button-group {
            flex-direction: column;
          }

          .hash-grid {
            grid-template-columns: 1fr;
          }
        }

        @media (min-width: 769px) {
          .hash-grid {
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
          }
        }

        .hash-generation-section {
          margin-bottom: 2rem;
        }

        .generate-button {
          padding: 0.75rem 1.5rem;
          background: #262c42;
          color: white;
          border: none;
          border-radius: 4px;
          font-size: 1rem;
          cursor: pointer;
          transition: background-color 0.3s ease;
        }

        .generate-button:hover:not(:disabled) {
          background: #262c42;
        }

        .generate-button:disabled {
          background: #9e9e9e;
          cursor: not-allowed;
        }

        .generated-hashes-grid {
          display: grid;
          gap: 1rem;
          margin-top: 1.5rem;
        }

        .hash-card {
          background: white;
          border: 1px solid #e0e0e0;
          border-radius: 8px;
          padding: 1rem;
          transition: box-shadow 0.3s ease;
        }

        .hash-card:hover {
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .hash-card-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 0.75rem;
        }

        .hash-algorithm {
          font-weight: 600;
          color: #262c42;
        }

        .hash-actions {
          display: flex;
          gap: 0.5rem;
        }

        .analyze-hash-button {
          padding: 0.25rem 0.75rem;
          background: #262c42;
          color: white;
          border: none;
          border-radius: 4px;
          font-size: 0.875rem;
          cursor: pointer;
          transition: background-color 0.3s ease;
          display: flex;
          align-items: center;
          gap: 0.25rem;
        }

        .analyze-hash-button:hover {
          background: #262c42;
        }

        .copy-button {
          padding: 0.25rem 0.5rem;
          background: #f5f5f5;
          border: none;
          border-radius: 4px;
          color: #666;
          cursor: pointer;
          transition: all 0.3s ease;
        }

        .copy-button:hover {
          background: #e0e0e0;
          color: #262c42;
        }

        .hash-value {
          background: #f8f9fa;
          padding: 0.75rem;
          border-radius: 4px;
          font-family: monospace;
          font-size: 0.875rem;
          overflow-x: auto;
          white-space: nowrap;
        }

        @media (min-width: 768px) {
          .generated-hashes-grid {
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
          }
        }

        @media (max-width: 767px) {
          .hash-input-group {
            flex-direction: column;
          }

          .tab-buttons {
            flex-direction: row;
            overflow-x: auto;
          }

          .hash-card-header {
            flex-direction: column;
            align-items: flex-start;
            gap: 0.5rem;
          }

          .hash-actions {
            width: 100%;
            justify-content: flex-end;
          }
        }

        .password-input-section {
          display: flex;
          flex-direction: column;
          gap: 1rem;
          margin-bottom: 1.5rem;
        }

        .password-input {
          padding: 0.75rem;
          border: 2px solid #e0e0e0;
          border-radius: 4px;
          font-size: 1rem;
          transition: border-color 0.3s ease;
        }

        .password-input:focus {
          border-color: #262c42;
          outline: none;
        }

        .analyze-button {
          padding: 0.75rem 1.5rem;
          background: #262c42;
          color: white;
          border: none;
          border-radius: 4px;
          font-size: 1rem;
          cursor: pointer;
          transition: background-color 0.3s ease;
        }

        .analyze-button:hover:not(:disabled) {
          background: #262c42;
        }

        .analyze-button:disabled {
          background: #9e9e9e;
          cursor: not-allowed;
        }

        .ml-metric-card {
          background: white;
          border-radius: 8px;
          padding: 1.5rem;
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .ml-metric-value {
          font-size: 2rem;
          font-weight: 600;
          margin: 0.5rem 0;
        }

        .strength-category {
          font-size: 1.1rem;
          color: #666;
          margin-bottom: 0.5rem;
        }

        .entropy-bar {
          height: 8px;
          background: #e0e0e0;
          border-radius: 4px;
          overflow: hidden;
          margin: 0.5rem 0;
        }

        .entropy-fill {
          height: 100%;
          background:  #262c42;
          transition: width 0.3s ease;
        }

        .warning {
          border-left: 4px solid #f44336;
        }

        .char-composition-section {
          background: #fff;
          border-radius: 8px;
          padding: 1.5rem;
          margin: 1rem 0;
          box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .char-types-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
          gap: 1rem;
          margin: 1rem 0;
        }

        .char-type {
          display: flex;
          flex-direction: column;
          align-items: center;
          padding: 1rem;
          background: #f5f5f5;
          border-radius: 8px;
          transition: all 0.3s ease;
          opacity: 0.6;
        }

        .char-type.present {
          opacity: 1;
          background: #e8f5e9;
          border-left: 4px solid #4caf50;
        }

        .char-type-label {
          font-size: 1.2rem;
          font-weight: 600;
          margin-bottom: 0.5rem;
        }

        .char-type-status {
          font-size: 1.5rem;
          margin: 0.5rem 0;
        }

        .char-type-count {
          font-size: 0.9rem;
          color: #666;
        }

        .composition-summary {
          margin-top: 1.5rem;
          padding-top: 1rem;
          border-top: 1px solid #eee;
        }

        .summary-item {
          display: flex;
          justify-content: space-between;
          padding: 0.5rem 0;
          font-size: 0.95rem;
        }

        .summary-item.warning {
          color: #f44336;
          font-weight: 500;
        }

        @media (max-width: 768px) {
          .char-types-grid {
            grid-template-columns: repeat(2, 1fr);
          }
        }
      `}</style>
    </div>
  );
};

export default VulnerabilityAnalysisPage; 