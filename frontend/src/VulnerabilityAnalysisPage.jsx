import React, { useState, useEffect, useCallback } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import './VulnerabilityAnalysisPage.css';
import CryptoJS from 'crypto-js';

const calculateLocalAnalysis = (password) => {
  // Calculate entropy bits
  const charsetSize = (
    (/[a-z]/.test(password) ? 26 : 0) +
    (/[A-Z]/.test(password) ? 26 : 0) +
    (/[0-9]/.test(password) ? 10 : 0) +
    (/[^A-Za-z0-9]/.test(password) ? 32 : 0)
  );
  const entropyBits = Math.log2(Math.pow(charsetSize, password.length));
  
  // Calculate strength score
  let strengthScore = Math.min(100, Math.floor(entropyBits * 1.5));
  
  // Apply penalties
  if (/(.)\1{2,}/.test(password)) strengthScore -= 20;
  if (/[a-z]{4,}/.test(password)) strengthScore -= 15;
  if (/123|abc|qwerty/.test(password)) strengthScore -= 30;
  
  // Determine strength category
  let strengthCategory;
  if (strengthScore >= 80) strengthCategory = 'Very Strong';
  else if (strengthScore >= 60) strengthCategory = 'Strong';
  else if (strengthScore >= 40) strengthCategory = 'Moderate';
  else if (strengthScore >= 20) strengthCategory = 'Weak';
  else strengthCategory = 'Very Weak';
  
  // Calculate crack times
  const guessesPerSecond = {
    online: 100,  // 100 guesses per second for online attacks
    offline_fast: 1e10,  // 10 billion guesses per second for fast offline attacks
    offline_slow: 1e4    // 10,000 guesses per second for slow offline attacks
  };
  
  const possibleCombinations = Math.pow(charsetSize || 1, password.length || 1);
  const crackTimes = {};
  
  Object.entries(guessesPerSecond).forEach(([type, speed]) => {
    // Add some randomness to make it more realistic
    const variability = 0.2; // 20% variability
    const effectiveSpeed = speed * (1 + (Math.random() * 2 - 1) * variability);
    const seconds = possibleCombinations / (2 * effectiveSpeed);
    
    // Adjust time based on password complexity
    const complexityMultiplier = 1 + (
      (/[A-Z]/.test(password) ? 0.3 : 0) +
      (/[0-9]/.test(password) ? 0.3 : 0) +
      (/[^A-Za-z0-9]/.test(password) ? 0.4 : 0)
    );
    
    const adjustedSeconds = seconds * complexityMultiplier;
    
    crackTimes[type] = {
      seconds: adjustedSeconds,
      time_readable: formatTime(adjustedSeconds)
    };
  });
  
  // Identify patterns and vulnerabilities
  const patterns = [];
  const attackTypes = [];
  
  if (/(.)\1{2,}/.test(password)) {
    patterns.push({
      type: 'Repetition',
      pattern: 'Repeated characters',
      severity: 'high'
    });
  }
  
  if (/[a-z]{4,}/.test(password)) {
    patterns.push({
      type: 'Dictionary',
      pattern: 'Common word pattern',
      severity: 'medium'
    });
  }
  
  if (/123|abc|qwerty/.test(password)) {
    patterns.push({
      type: 'Sequence',
      pattern: 'Common sequence',
      severity: 'high'
    });
  }
  
  if (password.length < 8) {
    attackTypes.push({
      name: 'Brute Force',
      description: 'Password is too short and can be quickly brute forced',
      risk_level: 'High'
    });
  }
  
  if (/^[a-zA-Z]+$/.test(password)) {
    attackTypes.push({
      name: 'Dictionary Attack',
      description: 'Password contains only letters and may be vulnerable to dictionary attacks',
      risk_level: 'Medium'
    });
  }
  
  return {
    strength_score: Math.max(0, strengthScore),
    strength_category: strengthCategory,
    suggestions: [
      'Use a mix of character types',
      'Avoid common patterns and sequences',
      'Make the password longer',
      'Avoid repeated characters'
    ],
    details: {
      entropy_bits: entropyBits,
      crack_times: crackTimes,
      length: password.length,
      has_uppercase: /[A-Z]/.test(password),
      has_lowercase: /[a-z]/.test(password),
      has_numbers: /[0-9]/.test(password),
      has_symbols: /[^A-Za-z0-9]/.test(password),
      char_types: (
        (/[A-Z]/.test(password) ? 1 : 0) +
        (/[a-z]/.test(password) ? 1 : 0) +
        (/[0-9]/.test(password) ? 1 : 0) +
        (/[^A-Za-z0-9]/.test(password) ? 1 : 0)
      ),
      repeating_chars: (password.match(/(.)\1{2,}/g) || []).length
    },
    patterns,
    attack_types: attackTypes,
    is_local_analysis: true
  };
};

const formatTime = (seconds) => {
  if (seconds < 1e-9) return 'nano-seconds';
  if (seconds < 1e-6) return 'micro-seconds';
  if (seconds < 1e-3) return 'milli-seconds';
  if (seconds < 1) return `${(seconds * 1000).toFixed(2)} milliseconds`;
  if (seconds < 60) return `${seconds.toFixed(1)} seconds`;
  if (seconds < 3600) return `${(seconds / 60).toFixed(1)} minutes`;
  if (seconds < 86400) return `${(seconds / 3600).toFixed(1)} hours`;
  if (seconds < 31536000) return `${(seconds / 86400).toFixed(1)} days`;
  if (seconds < 31536000 * 100) return `${(seconds / 31536000).toFixed(1)} years`;
  return 'centuries';
};

// Add this function near the top with other utility functions
const performLocalHashAnalysis = (hash, algorithm) => {
  // Basic hash analysis without server
  const analysis = {
    vulnerability_score: 0,
    confidence: 0.85,
    algorithm_details: {
      name: algorithm,
      bit_length: getBitLength(algorithm),
      quantum_resistant: isQuantumResistant(algorithm)
    },
    risk_factors: [],
    recommendations: []
  };

  // Analyze hash characteristics
  if (algorithm === 'md5') {
    analysis.vulnerability_score = 0.8;
    analysis.risk_factors.push({
      type: 'Collision Vulnerability',
      severity: 'high',
      description: 'MD5 is cryptographically broken and susceptible to collision attacks.'
    });
    analysis.recommendations.push(
      'Migrate to a stronger hash algorithm like SHA-256 or BLAKE2b',
      'If possible, rehash existing data with a stronger algorithm'
    );
  } else if (algorithm === 'sha1') {
    analysis.vulnerability_score = 0.6;
    analysis.risk_factors.push({
      type: 'Theoretical Weakness',
      severity: 'medium',
      description: 'SHA-1 has known theoretical weaknesses and is not recommended for new applications.'
    });
    analysis.recommendations.push(
      'Consider upgrading to SHA-256 or newer hash functions',
      'Monitor for any new vulnerabilities in SHA-1'
    );
  } else if (algorithm === 'sha256') {
    analysis.vulnerability_score = 0.2;
    analysis.risk_factors.push({
      type: 'Quantum Computing',
      severity: 'low',
      description: 'While currently secure, may be vulnerable to future quantum computing attacks.'
    });
    analysis.recommendations.push(
      'Consider quantum-resistant algorithms for long-term security',
      'Implement regular security reviews'
    );
  } else if (algorithm === 'sha3_256') {
    analysis.vulnerability_score = 0.1;
    analysis.risk_factors.push({
      type: 'Implementation',
      severity: 'low',
      description: 'Strong algorithm, but ensure proper implementation and salt usage.'
    });
    analysis.recommendations.push(
      'Ensure proper implementation of the algorithm',
      'Use appropriate salt values'
    );
  } else if (algorithm === 'blake2b') {
    analysis.vulnerability_score = 0.1;
    analysis.risk_factors.push({
      type: 'Best Practice',
      severity: 'low',
      description: 'Modern and secure, but ensure proper implementation.'
    });
    analysis.recommendations.push(
      'Maintain up-to-date implementations',
      'Follow security best practices for key handling'
    );
  }

  // Validate hash format
  const expectedLength = getExpectedLength(algorithm);
  if (!isValidHashFormat(hash, algorithm)) {
    analysis.risk_factors.push({
      type: 'Format Error',
      severity: 'high',
      description: `Invalid hash format for ${algorithm.toUpperCase()}. Expected length: ${expectedLength} characters.`
    });
    analysis.recommendations.push('Verify the hash was generated correctly');
    analysis.vulnerability_score = 1.0;
  }

  return analysis;
};

// Helper functions for local hash analysis
const getBitLength = (algorithm) => {
  const bitLengths = {
    md5: 128,
    sha1: 160,
    sha256: 256,
    sha3_256: 256,
    blake2b: 512
  };
  return bitLengths[algorithm] || 256;
};

const isQuantumResistant = (algorithm) => {
  return ['sha3_256', 'blake2b'].includes(algorithm);
};

const getExpectedLength = (algorithm) => {
  const lengths = {
    md5: 32,
    sha1: 40,
    sha256: 64,
    sha3_256: 64,
    blake2b: 128
  };
  return lengths[algorithm] || 64;
};

const isValidHashFormat = (hash, algorithm) => {
  const expectedLength = getExpectedLength(algorithm);
  const hexRegex = /^[0-9a-fA-F]+$/;
  return hash.length === expectedLength && hexRegex.test(hash);
};

const VulnerabilityAnalysisPage = () => {
  const [password, setPassword] = useState('');
  const [analysis, setAnalysis] = useState(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const location = useLocation();
  const navigate = useNavigate();

  // Add new state for hash analysis
  const [hashValue, setHashValue] = useState('');
  const [hashAlgorithm, setHashAlgorithm] = useState('sha256');
  const [hashAnalysis, setHashAnalysis] = useState(null);
  const [isHashLoading, setIsHashLoading] = useState(false);
  const [hashError, setHashError] = useState(null);

  // Add after the existing state declarations in VulnerabilityAnalysisPage component
  const [generatedHashes, setGeneratedHashes] = useState(null);
  const [selectedGeneratedHash, setSelectedGeneratedHash] = useState(null);

  useEffect(() => {
    // Get password from navigation state if available
    if (location.state && location.state.password) {
      console.log('Password received from navigation state:', location.state.password);
      setPassword(location.state.password);
      analyzePassword(location.state.password);
    }
  }, [location]);

  const analyzePassword = async (pwdToAnalyze) => {
    setIsLoading(true);
    setError(null);
    
    try {
      console.log('Analyzing password:', pwdToAnalyze);
      
      // Get token from localStorage
      const token = localStorage.getItem('token');
      if (!token) {
        setError('Authentication required. Please log in.');
        setIsLoading(false);
        return;
      }
      
      let analysisResult;
      
      try {
        // Log the request details
        console.log('Sending request to backend with:', {
          url: 'http://localhost:5000/api/analyze-password',
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: { password: pwdToAnalyze }
        });

        const response = await fetch('http://localhost:5000/api/analyze-password', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`
          },
          body: JSON.stringify({ password: pwdToAnalyze })
        });
        
        // Log the raw response
        console.log('Raw response:', response);
        console.log('Response status:', response.status);
        
        if (!response.ok) {
          if (response.status === 401) {
            setError('Authentication required. Please log in.');
            navigate('/login');
            return;
          }
          
          // Try to get error details from response
          let errorDetail = '';
          try {
            const errorData = await response.json();
            errorDetail = errorData.message || errorData.error || '';
          } catch (e) {
            errorDetail = await response.text();
          }
          
          throw new Error(`Server Error (${response.status}): ${errorDetail}`);
        }
        
        const data = await response.json();
        console.log('Backend analysis result:', data);
        
        // Validate the response data
        if (!data) {
          throw new Error('Empty response from server');
        }

        // Map backend response to frontend structure
        analysisResult = {
          strength_score: data.score || 0,
          strength_category: data.category || 'Unknown',
          suggestions: data.suggestions || [],
          crack_times: data.crack_times || {},
          patterns: data.patterns || [],
          confidence: data.confidence,  // Add confidence directly from response
          details: {
            entropy_bits: data.entropy || 0,
            length: data.features?.length || pwdToAnalyze.length,
            has_uppercase: data.features?.has_upper || false,
            has_lowercase: data.features?.has_lower || false,
            has_numbers: data.features?.has_digit || false,
            has_symbols: data.features?.has_special || false,
            char_types: data.features?.char_types || 0,
            repeating_chars: (pwdToAnalyze.match(/(.)\1{2,}/g) || []).length
          }
        };

        console.log('Raw backend response:', data);  // Add debug logging
        console.log('Final processed analysis result:', analysisResult);
        
      } catch (backendError) {
        console.error('Backend analysis error:', backendError);
        console.error('Error stack:', backendError.stack);
        setError(`Backend Error: ${backendError.message}`);
        analysisResult = calculateLocalAnalysis(pwdToAnalyze);
      }
      
      setAnalysis(analysisResult);
      if (analysisResult.is_local_analysis) {
        setError('Note: Using local analysis mode due to server unavailability');
      }
      
    } catch (err) {
      console.error('Error in password analysis:', err);
      console.error('Error stack:', err.stack);
      const localAnalysis = calculateLocalAnalysis(pwdToAnalyze);
      setAnalysis(localAnalysis);
      setError(`Analysis Error: ${err.message}`);
    } finally {
      setIsLoading(false);
    }
  };

  const analyzeHash = async (hashToAnalyze, algorithm) => {
    setIsHashLoading(true);
    setHashError(null);
    
    try {
      // Try server-side analysis first
      const token = localStorage.getItem('token');
      let serverAnalysis = null;

      if (token) {
        try {
          const response = await fetch('http://localhost:5000/api/analyze-hash', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify({ hash: hashToAnalyze, algorithm })
          });

          if (response.ok) {
            serverAnalysis = await response.json();
            console.log('Server hash analysis:', serverAnalysis);
          }
        } catch (serverError) {
          console.log('Server analysis failed, falling back to local:', serverError);
        }
      }

      // If server analysis failed or no token, use local analysis
      if (!serverAnalysis) {
        console.log('Performing local hash analysis');
        const localAnalysis = performLocalHashAnalysis(hashToAnalyze, algorithm);
        setHashAnalysis(localAnalysis);
        if (!token) {
          setHashError('Note: Using local analysis mode. Login for enhanced analysis.');
        }
      } else {
        setHashAnalysis(serverAnalysis);
      }
      
    } catch (err) {
      console.error('Error in hash analysis:', err);
      setHashError(`Analysis Error: ${err.message}`);
      
      // Fallback to local analysis on error
      const localAnalysis = performLocalHashAnalysis(hashToAnalyze, algorithm);
      setHashAnalysis(localAnalysis);
    } finally {
      setIsHashLoading(false);
    }
  };

  const handlePasswordChange = (e) => {
    setPassword(e.target.value);
  };

  const handleAnalyzeClick = () => {
    analyzePassword(password);
  };

  const handleHashSubmit = () => {
    if (!hashValue) return;
    analyzeHash(hashValue, hashAlgorithm);
  };

  const getStrengthColor = (score) => {
    score = Math.max(0, Math.min(100, score)); // Ensure score is between 0 and 100
    if (score >= 80) return '#4CAF50'; // Green
    if (score >= 60) return '#8BC34A'; // Light Green
    if (score >= 40) return '#FFC107'; // Amber
    if (score >= 20) return '#FF9800'; // Orange
    return '#F44336'; // Red
  };

  const getRiskLevelColor = (level) => {
    if (level === 'High') return '#F44336'; // Red
    if (level === 'Medium') return '#FF9800'; // Orange
    return '#4CAF50'; // Green
  };

  // Add this function in the VulnerabilityAnalysisPage component
  const generateHashes = (password) => {
    const hashes = {
      md5: CryptoJS.MD5(password).toString(),
      sha1: CryptoJS.SHA1(password).toString(),
      sha256: CryptoJS.SHA256(password).toString(),
      sha3_256: CryptoJS.SHA3(password, { outputLength: 256 }).toString(),
      // Note: BLAKE2b is not available in CryptoJS, so we'll skip it for now
    };
    setGeneratedHashes(hashes);
  };

  // Add this function in the VulnerabilityAnalysisPage component
  const analyzeGeneratedHash = (hash, algorithm) => {
    setHashValue(hash);
    setHashAlgorithm(algorithm);
    setSelectedGeneratedHash({ hash, algorithm });
    analyzeHash(hash, algorithm);
  };

  return (
    <div className="vulnerability-analysis-container">
      <h1 className="main-title">Security Analysis Dashboard</h1>
      
      <div className="analysis-tabs">
        {/* Password Analysis Section */}
        <div className="analysis-section password-section">
          <div className="section-header">
            <h2>
              <i className="fas fa-key"></i>
              Password Vulnerability Analysis
            </h2>
          </div>
          
          <div className="password-input-section">
            <input
              type="text"
              value={password}
              onChange={handlePasswordChange}
              placeholder="Enter password to analyze"
              className="password-input"
            />
            <button 
              onClick={handleAnalyzeClick} 
              className="analyze-button"
              disabled={isLoading || !password}
            >
              {isLoading ? 'Analyzing...' : 'Analyze Password'}
            </button>
          </div>

          {error && <div className="error-message">{error}</div>}
          
          {isLoading && (
            <div className="loading-spinner">
              <div className="spinner"></div>
              <p>Analyzing password strength...</p>
            </div>
          )}

          {analysis && !isLoading && (
            <div className="analysis-results">
              <div className="strength-meter">
                <h2>Password Strength</h2>
                <div className="strength-bar-container">
                  <div 
                    className="strength-bar" 
                    style={{ 
                      width: `${Math.max(1, Math.min(100, analysis.strength_score * 100))}%`,
                      backgroundColor: getStrengthColor(analysis.strength_score * 100)
                    }}
                  ></div>
                </div>
                <div className="strength-score">
                  <span>Score: </span>
                  <span style={{ color: getStrengthColor(analysis.strength_score * 100) }}>
                    {Math.round(analysis.strength_score * 100)}/100
                  </span>
                  <span> ({analysis.strength_category})</span>
                  {analysis?.confidence && (
                    <span className="confidence-score">
                      {' '}• ML Confidence: {(analysis.confidence * 100).toFixed(3)}%
                    </span>
                  )}
                </div>
                <div className="password-metrics">
                  <div className="metric-item">
                    <span>Length:</span>
                    <span>{analysis.details.length} characters</span>
                  </div>
                  <div className="metric-item">
                    <span>Entropy:</span>
                    <span>{analysis.details.entropy_bits.toFixed(2)} bits</span>
                  </div>
                  <div className="metric-item">
                    <span>Character Types:</span>
                    <span>{analysis.details.char_types}/4</span>
                  </div>
                  {analysis.details.repeating_chars > 0 && (
                    <div className="metric-item warning">
                      <span>Repeating Characters: </span>
                      <span>{analysis.details.repeating_chars}</span>
                    </div>
                  )}
                </div>
              </div>
              
              {/* Attack Methods Analysis */}
              <div className="attack-methods">
                <h2>Attack Methods Analysis</h2>
                <div className="attack-grid">
                  {analysis.crack_times && typeof analysis.crack_times === 'object' && Object.entries(analysis.crack_times).map(([method, data]) => {
                    // Skip if data is null or undefined
                    if (!data) return null;
                    
                    // Handle Infinity values for display
                    const timeReadable = data.time_readable || 
                      (data.seconds === Infinity ? 'centuries' : 
                       data.seconds === -Infinity ? 'instant' : 
                       formatTime(data.seconds));

                    return (
                      <div key={method} className="attack-card">
                        <h3>{method.split('_').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ')}</h3>
                        <div className="attack-details">
                          <div className="time-to-crack">
                            <span className="label">Time to Crack:</span>
                            <span className="value">{timeReadable}</span>
                          </div>
                          {typeof data.entropy_contribution === 'number' && (
                            <div className="entropy-contribution">
                              <span className="label">Entropy Contribution:</span>
                              <div className="entropy-bar">
                                <div 
                                  className="entropy-fill"
                                  style={{ width: `${data.entropy_contribution}%` }}
                                />
                              </div>
                              <span className="value">{data.entropy_contribution.toFixed(1)}%</span>
                            </div>
                          )}
                          {data.description && (
                            <p className="attack-description">{data.description}</p>
                          )}
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
              
              {/* Password Patterns */}
              {analysis.patterns && analysis.patterns.length > 0 && (
                <div className="patterns-section">
                  <h2>Detected Patterns</h2>
                  <div className="patterns-grid">
                    {analysis.patterns.map((pattern, index) => (
                      <div key={index} className="pattern-card">
                        <div className="pattern-header">
                          <h3>{pattern.type}</h3>
                          <span className={`severity-badge ${pattern.severity.toLowerCase()}`}>
                            {pattern.severity}
                          </span>
                        </div>
                        <p className="pattern-value">{pattern.pattern}</p>
                      </div>
                    ))}
                  </div>
                </div>
              )}
              
              {/* Suggestions */}
              {analysis.suggestions && analysis.suggestions.length > 0 && (
                <div className="suggestions-section">
                  <h2>Improvement Suggestions</h2>
                  <ul className="suggestions-list">
                    {analysis.suggestions.map((suggestion, index) => (
                      <li key={index} className="suggestion-item">
                        {suggestion}
                      </li>
                    ))}
                  </ul>
                </div>
              )}

              {/* Character Composition */}
              <div className="char-composition-section">
                <h2>Character Composition</h2>
                <div className="char-types-grid">
                  <div className={`char-type ${analysis.details.has_uppercase ? 'present' : ''}`}>
                    <span className="char-type-label">ABC</span>
                    <span className="char-type-status">{analysis.details.has_uppercase ? '✓' : '×'}</span>
                  </div>
                  <div className={`char-type ${analysis.details.has_lowercase ? 'present' : ''}`}>
                    <span className="char-type-label">abc</span>
                    <span className="char-type-status">{analysis.details.has_lowercase ? '✓' : '×'}</span>
                  </div>
                  <div className={`char-type ${analysis.details.has_numbers ? 'present' : ''}`}>
                    <span className="char-type-label">123</span>
                    <span className="char-type-status">{analysis.details.has_numbers ? '✓' : '×'}</span>
                  </div>
                  <div className={`char-type ${analysis.details.has_symbols ? 'present' : ''}`}>
                    <span className="char-type-label">#@!</span>
                    <span className="char-type-status">{analysis.details.has_symbols ? '✓' : '×'}</span>
                  </div>
                </div>
              </div>

              {/* New ML Analysis Section */}
              <div className="ml-analysis-section">
                <h2>Machine Learning Analysis</h2>
                
                <div className="ml-metrics-grid">
                  {/* ML Confidence Score */}
                  <div className="ml-metric-card">
                    <h3>ML Confidence</h3>
                    <div className="ml-metric-value" style={{
                      color: analysis?.confidence > 0.7 ? '#4CAF50' : 
                             analysis?.confidence > 0.4 ? '#FFC107' : '#F44336'
                    }}>
                      {((analysis?.confidence || 0) * 100).toFixed(3)}%
                    </div>
                    <div className="ml-metric-description">
                      Model's confidence in its analysis
                    </div>
                  </div>

                  {/* Character Composition */}
                  <div className="ml-metric-card">
                    <h3>Character Types</h3>
                    <div className="char-types-grid">
                      <div className={`char-type ${analysis?.details?.has_uppercase ? 'present' : ''}`}>
                        ABC
                      </div>
                      <div className={`char-type ${analysis?.details?.has_lowercase ? 'present' : ''}`}>
                        abc
                      </div>
                      <div className={`char-type ${analysis?.details?.has_numbers ? 'present' : ''}`}>
                        123
                      </div>
                      <div className={`char-type ${analysis?.details?.has_symbols ? 'present' : ''}`}>
                        #@!
                      </div>
                    </div>
                    <div className="ml-metric-description">
                      {analysis?.details?.char_types || 0}/4 character types used
                    </div>
                  </div>

                  {/* Entropy Analysis */}
                  <div className="ml-metric-card">
                    <h3>Entropy Analysis</h3>
                    <div className="ml-metric-value">
                      {analysis?.details?.entropy_bits ? analysis.details.entropy_bits.toFixed(2) : '0.00'} bits
                    </div>
                    <div className="entropy-bar">
                      <div 
                        className="entropy-fill"
                        style={{ width: `${Math.min(100, analysis?.details?.entropy_bits || 0)}%` }}
                      />
                    </div>
                    <div className="ml-metric-description">
                      Password randomness score
                    </div>
                  </div>

                  {/* Pattern Detection */}
                  {analysis?.details?.repeating_chars > 0 && (
                    <div className="ml-metric-card warning">
                      <h3>Pattern Warning</h3>
                      <div className="ml-metric-value">
                        {analysis.details.repeating_chars} repeating characters
                      </div>
                      <div className="ml-metric-description">
                        Repeated characters make your password weaker
                      </div>
                    </div>
                  )}
                </div>

                {/* ML-Based Recommendations */}
                {analysis?.confidence < 0.7 && (
                  <div className="ml-recommendations">
                    <h3>ML Model Recommendations</h3>
                    <ul className="ml-recommendations-list">
                      {analysis?.confidence < 0.4 && (
                        <li>Your password structure is highly unusual - consider using a more standard pattern</li>
                      )}
                      {analysis?.details?.char_types < 3 && (
                        <li>Increase complexity by using more character types</li>
                      )}
                      {analysis?.details?.entropy_bits < 50 && (
                        <li>Increase password randomness for better security</li>
                      )}
                    </ul>
                  </div>
                )}
              </div>
            </div>
          )}
        </div>

        {/* Hash Analysis Section */}
        <div className="analysis-section hash-section">
          <div className="section-header">
            <h2>
              <i className="fas fa-hashtag"></i>
              Hash Function Analysis
            </h2>
          </div>

          <div className="hash-tabs">
            <div className="tab-buttons">
              <button 
                className={`tab-button ${!generatedHashes ? 'active' : ''}`}
                onClick={() => setGeneratedHashes(null)}
              >
                Analyze Hash
              </button>
              <button 
                className={`tab-button ${generatedHashes ? 'active' : ''}`}
                onClick={() => setGeneratedHashes({})}
              >
                Generate Hash
              </button>
            </div>

            {!generatedHashes ? (
              // Original Hash Analysis Input
              <div className="hash-input-section">
                <div className="hash-input-group">
                  <input
                    type="text"
                    value={hashValue}
                    onChange={(e) => setHashValue(e.target.value)}
                    placeholder="Enter hash value to analyze"
                    className="hash-input"
                  />
                  <select
                    value={hashAlgorithm}
                    onChange={(e) => setHashAlgorithm(e.target.value)}
                    className="algorithm-select"
                  >
                    <option value="md5">MD5</option>
                    <option value="sha1">SHA-1</option>
                    <option value="sha256">SHA-256</option>
                    <option value="sha3_256">SHA3-256</option>
                    <option value="blake2b">BLAKE2b</option>
                  </select>
                </div>
                <button 
                  onClick={handleHashSubmit} 
                  className="analyze-button"
                  disabled={isHashLoading || !hashValue}
                >
                  {isHashLoading ? 'Analyzing...' : 'Analyze Hash'}
                </button>
              </div>
            ) : (
              // Hash Generation Section
              <div className="hash-generation-section">
                <div className="hash-input-group">
                  <input
                    type="text"
                    value={password}
                    onChange={handlePasswordChange}
                    placeholder="Enter text to generate hashes"
                    className="hash-input"
                  />
                  <button
                    onClick={() => generateHashes(password)}
                    className="generate-button"
                    disabled={!password}
                  >
                    Generate Hashes
                  </button>
                </div>

                {Object.keys(generatedHashes).length > 0 && (
                  <div className="generated-hashes-grid">
                    {Object.entries(generatedHashes).map(([algo, hash]) => (
                      <div key={algo} className="hash-card">
                        <div className="hash-card-header">
                          <span className="hash-algorithm">{algo.toUpperCase()}</span>
                          <div className="hash-actions">
                            <button
                              onClick={() => analyzeGeneratedHash(hash, algo)}
                              className="analyze-hash-button"
                              title="Analyze this hash"
                            >
                              <i className="fas fa-search"></i> Analyze
                            </button>
                            <button
                              onClick={() => {
                                navigator.clipboard.writeText(hash);
                              }}
                              className="copy-button"
                              title="Copy to clipboard"
                            >
                              <i className="fas fa-copy"></i>
                            </button>
                          </div>
                        </div>
                        <div className="hash-value">
                          <code>{hash}</code>
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            )}
          </div>

          {hashError && <div className="error-message">{hashError}</div>}
          
          {isHashLoading && (
            <div className="loading-spinner">
              <div className="spinner"></div>
              <p>Analyzing hash...</p>
            </div>
          )}

          {hashAnalysis && !isHashLoading && (
            <div className="hash-analysis-results">
              {/* Vulnerability Score */}
              <div className="hash-score-section">
                <h3>Vulnerability Assessment</h3>
                <div className="vulnerability-meter">
                  <div 
                    className="vulnerability-bar"
                    style={{
                      width: `${hashAnalysis.vulnerability_score * 100}%`,
                      backgroundColor: hashAnalysis.vulnerability_score > 0.7 ? '#F44336' :
                                     hashAnalysis.vulnerability_score > 0.4 ? '#FFC107' : '#4CAF50'
                    }}
                  ></div>
                </div>
                <div className="score-details">
                  <span>Vulnerability Score: </span>
                  <span className="score-value">
                    {(hashAnalysis.vulnerability_score * 100).toFixed(1)}%
                  </span>
                  <span className="confidence">
                    (Confidence: {(hashAnalysis.confidence * 100).toFixed(3)}%)
                  </span>
                </div>
              </div>

              {/* Algorithm Details */}
              <div className="algorithm-details">
                <h3>Algorithm Information</h3>
                <div className="details-grid">
                  <div className="detail-item">
                    <span>Algorithm:</span>
                    <span>{hashAnalysis.algorithm_details.name.toUpperCase()}</span>
                  </div>
                  <div className="detail-item">
                    <span>Bit Length:</span>
                    <span>{hashAnalysis.algorithm_details.bit_length} bits</span>
                  </div>
                  <div className="detail-item">
                    <span>Quantum Resistant:</span>
                    <span className={hashAnalysis.algorithm_details.quantum_resistant ? 'safe' : 'warning'}>
                      {hashAnalysis.algorithm_details.quantum_resistant ? 'Yes' : 'No'}
                    </span>
                  </div>
                </div>
              </div>

              {/* Risk Factors */}
              {hashAnalysis.risk_factors && hashAnalysis.risk_factors.length > 0 && (
                <div className="risk-factors">
                  <h3>Risk Factors</h3>
                  <div className="risks-grid">
                    {hashAnalysis.risk_factors.map((risk, index) => (
                      <div key={index} className={`risk-card ${risk.severity}`}>
                        <div className="risk-header">
                          <span className="risk-type">{risk.type}</span>
                          <span className={`severity-badge ${risk.severity}`}>
                            {risk.severity}
                          </span>
                        </div>
                        <p className="risk-description">{risk.description}</p>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {/* Recommendations */}
              {hashAnalysis.recommendations && hashAnalysis.recommendations.length > 0 && (
                <div className="recommendations">
                  <h3>Security Recommendations</h3>
                  <ul className="recommendations-list">
                    {hashAnalysis.recommendations.map((rec, index) => (
                      <li key={index} className="recommendation-item">{rec}</li>
                    ))}
                  </ul>
                </div>
              )}
            </div>
          )}
        </div>
      </div>

      <style jsx>{`
        .vulnerability-analysis-container {
          max-width: 1200px;
          margin: 0 auto;
          padding: 2rem;
        }

        .main-title {
          text-align: center;
          color: #1a237e;
          margin-bottom: 2rem;
          font-size: 2rem;
        }

        .analysis-tabs {
          display: grid;
          grid-template-columns: 1fr;
          gap: 2rem;
        }

        .analysis-section {
          background: #fff;
          border-radius: 10px;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
          padding: 2rem;
          margin-bottom: 2rem;
        }

        .section-header {
          border-bottom: 2px solid #e0e0e0;
          margin-bottom: 1.5rem;
          padding-bottom: 1rem;
        }

        .section-header h2 {
          color: #1a237e;
          display: flex;
          align-items: center;
          gap: 0.5rem;
          margin: 0;
        }

        .section-header i {
          font-size: 1.5rem;
        }

        .password-section {
          border-top: 4px solid #1a237e;
        }

        .hash-section {
          border-top: 4px solid #0d47a1;
        }

        .hash-tabs {
          margin-bottom: 2rem;
        }

        .tab-buttons {
          display: flex;
          gap: 1rem;
          margin-bottom: 1.5rem;
        }

        .tab-button {
          padding: 0.75rem 1.5rem;
          background: none;
          border: none;
          border-bottom: 2px solid transparent;
          color: #666;
          font-size: 1rem;
          cursor: pointer;
          transition: all 0.3s ease;
        }

        .tab-button:hover {
          color: #1a237e;
        }

        .tab-button.active {
          color: #1a237e;
          border-bottom-color: #1a237e;
        }

        .hash-input-section {
          display: flex;
          flex-direction: column;
          gap: 1rem;
          margin-bottom: 1.5rem;
        }

        .hash-input-group {
          display: flex;
          gap: 1rem;
        }

        .hash-input {
          flex: 1;
          padding: 0.75rem;
          border: 2px solid #e0e0e0;
          border-radius: 4px;
          font-size: 1rem;
          transition: border-color 0.3s ease;
        }

        .hash-input:focus {
          border-color: #1a237e;
          outline: none;
        }

        .algorithm-select {
          min-width: 150px;
          padding: 0.75rem;
          border: 2px solid #e0e0e0;
          border-radius: 4px;
          font-size: 1rem;
          background: #fff;
          cursor: pointer;
        }

        .algorithm-select:focus {
          border-color: #1a237e;
          outline: none;
        }

        .analyze-button {
          padding: 0.75rem 1.5rem;
          background: #1a237e;
          color: white;
          border: none;
          border-radius: 4px;
          font-size: 1rem;
          cursor: pointer;
          transition: background-color 0.3s ease;
        }

        .analyze-button:hover:not(:disabled) {
          background: #0d47a1;
        }

        .analyze-button:disabled {
          background: #9e9e9e;
          cursor: not-allowed;
        }

        .vulnerability-meter {
          height: 10px;
          background: #e0e0e0;
          border-radius: 5px;
          overflow: hidden;
          margin: 1rem 0;
        }

        .vulnerability-bar {
          height: 100%;
          transition: width 0.3s ease, background-color 0.3s ease;
        }

        .score-details {
          display: flex;
          align-items: center;
          gap: 1rem;
          font-size: 1.1rem;
        }

        .score-value {
          font-weight: 600;
          color: #1a237e;
        }

        .confidence {
          color: #666;
          font-size: 0.9rem;
        }

        .details-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
          gap: 1rem;
          margin-top: 1rem;
        }

        .detail-item {
          display: flex;
          justify-content: space-between;
          padding: 1rem;
          background: #f5f5f5;
          border-radius: 4px;
          border-left: 4px solid #1a237e;
        }

        .risks-grid {
          display: grid;
          grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
          gap: 1rem;
          margin-top: 1rem;
        }

        .risk-card {
          padding: 1rem;
          border-radius: 4px;
          background: #f5f5f5;
        }

        .risk-card.high { border-left: 4px solid #f44336; }
        .risk-card.medium { border-left: 4px solid #ffc107; }
        .risk-card.low { border-left: 4px solid #4caf50; }

        .risk-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 0.5rem;
        }

        .severity-badge {
          padding: 0.25rem 0.75rem;
          border-radius: 12px;
          font-size: 0.8rem;
          font-weight: 500;
          text-transform: uppercase;
        }

        .severity-badge.high {
          background: #ffebee;
          color: #f44336;
        }

        .severity-badge.medium {
          background: #fff8e1;
          color: #ffc107;
        }

        .severity-badge.low {
          background: #e8f5e9;
          color: #4caf50;
        }

        .recommendations-list {
          list-style: none;
          padding: 0;
          margin: 1rem 0;
        }

        .recommendation-item {
          padding: 1rem;
          margin-bottom: 0.5rem;
          background: #f5f5f5;
          border-radius: 4px;
          border-left: 4px solid #1a237e;
        }

        .safe { color: #4caf50; }
        .warning { color: #f44336; }

        @media (min-width: 1024px) {
          .analysis-tabs {
            grid-template-columns: 1fr 1fr;
          }
        }

        @media (max-width: 768px) {
          .hash-input-group {
            flex-direction: column;
          }

          .algorithm-select {
            width: 100%;
          }
        }

        .button-group {
          display: flex;
          gap: 1rem;
          margin-top: 1rem;
        }

        .generate-hash-button {
          padding: 0.75rem 1.5rem;
          background: #2962ff;
          color: white;
          border: none;
          border-radius: 4px;
          font-size: 1rem;
          cursor: pointer;
          transition: background-color 0.3s ease;
        }

        .generate-hash-button:hover:not(:disabled) {
          background: #1565c0;
        }

        .generate-hash-button:disabled {
          background: #9e9e9e;
          cursor: not-allowed;
        }

        .generated-hashes-section {
          margin-top: 2rem;
          padding: 1.5rem;
          background: #f8f9fa;
          border-radius: 8px;
          border: 1px solid #e0e0e0;
        }

        .generated-hashes-section h3 {
          margin: 0 0 1rem 0;
          color: #1a237e;
        }

        .hash-grid {
          display: grid;
          gap: 1rem;
        }

        .hash-item {
          background: white;
          padding: 1rem;
          border-radius: 4px;
          border: 1px solid #e0e0e0;
        }

        .hash-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 0.5rem;
        }

        .hash-algorithm {
          font-weight: 600;
          color: #1a237e;
        }

        .analyze-hash-button {
          padding: 0.25rem 0.75rem;
          background: #1a237e;
          color: white;
          border: none;
          border-radius: 4px;
          font-size: 0.875rem;
          cursor: pointer;
          transition: background-color 0.3s ease;
        }

        .analyze-hash-button:hover {
          background: #0d47a1;
        }

        .hash-value {
          display: flex;
          align-items: center;
          gap: 0.5rem;
          background: #f5f5f5;
          padding: 0.5rem;
          border-radius: 4px;
          font-family: monospace;
          font-size: 0.875rem;
          overflow-x: auto;
        }

        .hash-value code {
          flex: 1;
          overflow-x: auto;
          white-space: nowrap;
        }

        .copy-button {
          padding: 0.25rem;
          background: none;
          border: none;
          color: #666;
          cursor: pointer;
          transition: color 0.3s ease;
        }

        .copy-button:hover {
          color: #1a237e;
        }

        @media (max-width: 768px) {
          .button-group {
            flex-direction: column;
          }

          .hash-grid {
            grid-template-columns: 1fr;
          }
        }

        @media (min-width: 769px) {
          .hash-grid {
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
          }
        }

        .hash-generation-section {
          margin-bottom: 2rem;
        }

        .generate-button {
          padding: 0.75rem 1.5rem;
          background: #2962ff;
          color: white;
          border: none;
          border-radius: 4px;
          font-size: 1rem;
          cursor: pointer;
          transition: background-color 0.3s ease;
        }

        .generate-button:hover:not(:disabled) {
          background: #1565c0;
        }

        .generate-button:disabled {
          background: #9e9e9e;
          cursor: not-allowed;
        }

        .generated-hashes-grid {
          display: grid;
          gap: 1rem;
          margin-top: 1.5rem;
        }

        .hash-card {
          background: white;
          border: 1px solid #e0e0e0;
          border-radius: 8px;
          padding: 1rem;
          transition: box-shadow 0.3s ease;
        }

        .hash-card:hover {
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .hash-card-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          margin-bottom: 0.75rem;
        }

        .hash-algorithm {
          font-weight: 600;
          color: #1a237e;
        }

        .hash-actions {
          display: flex;
          gap: 0.5rem;
        }

        .analyze-hash-button {
          padding: 0.25rem 0.75rem;
          background: #1a237e;
          color: white;
          border: none;
          border-radius: 4px;
          font-size: 0.875rem;
          cursor: pointer;
          transition: background-color 0.3s ease;
          display: flex;
          align-items: center;
          gap: 0.25rem;
        }

        .analyze-hash-button:hover {
          background: #0d47a1;
        }

        .copy-button {
          padding: 0.25rem 0.5rem;
          background: #f5f5f5;
          border: none;
          border-radius: 4px;
          color: #666;
          cursor: pointer;
          transition: all 0.3s ease;
        }

        .copy-button:hover {
          background: #e0e0e0;
          color: #1a237e;
        }

        .hash-value {
          background: #f8f9fa;
          padding: 0.75rem;
          border-radius: 4px;
          font-family: monospace;
          font-size: 0.875rem;
          overflow-x: auto;
          white-space: nowrap;
        }

        @media (min-width: 768px) {
          .generated-hashes-grid {
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
          }
        }

        @media (max-width: 767px) {
          .hash-input-group {
            flex-direction: column;
          }

          .tab-buttons {
            flex-direction: row;
            overflow-x: auto;
          }

          .hash-card-header {
            flex-direction: column;
            align-items: flex-start;
            gap: 0.5rem;
          }

          .hash-actions {
            width: 100%;
            justify-content: flex-end;
          }
        }

        .password-input-section {
          display: flex;
          flex-direction: column;
          gap: 1rem;
          margin-bottom: 1.5rem;
        }

        .password-input {
          padding: 0.75rem;
          border: 2px solid #e0e0e0;
          border-radius: 4px;
          font-size: 1rem;
          transition: border-color 0.3s ease;
        }

        .password-input:focus {
          border-color: #1a237e;
          outline: none;
        }

        .analyze-button {
          padding: 0.75rem 1.5rem;
          background: #1a237e;
          color: white;
          border: none;
          border-radius: 4px;
          font-size: 1rem;
          cursor: pointer;
          transition: background-color 0.3s ease;
        }

        .analyze-button:hover:not(:disabled) {
          background: #0d47a1;
        }

        .analyze-button:disabled {
          background: #9e9e9e;
          cursor: not-allowed;
        }
      `}</style>
    </div>
  );
};

export default VulnerabilityAnalysisPage; 